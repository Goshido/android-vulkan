#ifndef REFLECTION_COMMON_PS
#define REFLECTION_COMMON_PS


#include "lightup-common.ps"


#define PREFILTER_MAX_MIP_LEVEL     8.0H

[[vk::binding ( 0, 2 )]]
TextureCube<float32_t4>     g_prefilter:    register ( t1 );

struct InputData
{
    linear float32_t4       _pixel:         SV_Position;
};

struct OutputData
{
    [[vk::location (0)]]
    float32_t4              _color:         SV_Target0;
};

//----------------------------------------------------------------------------------------------------------------------

float32_t4 RestoreLocationViewUnnormalized ( in float32_t2 locationImage, in float32_t depth )
{
    const float32_t2 alpha = mad ( locationImage, _invResolutionFactor, (float32_t2)( -1.0F ) );
    return mul ( _cvvToView, float32_t4 ( alpha, depth, 1.0F ) );
}

float32_t Roughness2Mip ( in float16_t roughness )
{
    // It's emperical ease function. Please plot the graph to see what happens.
    const float16_t mip = 8.42H - 8.41H / ( 1.0H + pow ( roughness / 0.2584H, 2.164H ) );
    return (float32_t)clamp ( mip, 0.0H, PREFILTER_MAX_MIP_LEVEL );
}

float16_t3 GetReflection ( in float16_t3 toFragmentView )
{
    float16_t roughness;
    float16_t metallic;
    GetParams ( roughness, metallic );

    const float16_t3 directionView = -toFragmentView;
    const float16_t3 normalView = RestoreNormalView ();
    const float16_t dN = max ( 0.0H, dot ( directionView, normalView ) );
    const float16_t3 freshnel = GetFresnel ( dN, metallic, GetAlbedo () );

    const float32_t3 refl = -mul ( (float32_t3x3)_viewToWorld, (float32_t3)( reflect ( directionView, normalView ) ) );
    const float32_t mip = Roughness2Mip ( roughness );

    const float16_t3 prefilterColor = (float16_t3)g_prefilter.SampleLevel ( g_prefilterSampler, refl, mip ).xyz;

    const float16_t2 brdf = (float16_t2)g_brdf.Sample (
        g_brdfSampler, float32_t2 ( (float32_t)dN, 1.0F - roughness )
    ).xy;

    return prefilterColor * mad ( freshnel, (float16_t3)brdf.x, (float16_t3)brdf.y );
}


#endif // REFLECTION_COMMON_PS
