// The implementation is based on ideas from LearnOpenGL resourse
// see https://learnopengl.com/PBR/Theory
// see https://learnopengl.com/PBR/Lighting

#define EPSILON             1.0e-3H
#define MINIMUM_F0          4.0e-2H
#define PI                  3.141592H
#define INVERSE_PI          0.31830H

// It was set by empirical test.
#define SHADOW_MAP_BIAS     9.9e-1F

[[vk::binding ( 0, 0 )]]
[[vk::input_attachment_index (0)]]
SubpassInput<float4>        g_albedo;

[[vk::binding ( 1, 0 )]]
[[vk::input_attachment_index (1)]]
SubpassInput<float4>        g_normal;

[[vk::binding ( 2, 0 )]]
[[vk::input_attachment_index (2)]]
SubpassInput<float4>        g_params;

[[vk::binding ( 3, 0 )]]
[[vk::input_attachment_index (3)]]
SubpassInput<float>         g_depth;


[[vk::binding ( 4, 0 )]]
cbuffer ViewData:                           register ( b0 )
{
    matrix                  _cvvToView;

    // Optimiztion:
    // must be equal: 2.0F / resolution.
    float2                  _invResolutionFactor;
    float2                  _padding0_0;
};

[[vk::binding ( 0, 1 )]]
TextureCube<float>          g_shadowmap:    register ( t0 );

[[vk::binding ( 1, 1 )]]
SamplerComparisonState      g_sampler:      register ( s0 );

[[vk::binding ( 2, 1 )]]
cbuffer LightData:                          register ( b1 )
{
    matrix                  _lightProjection;
    matrix                  _viewToLight;

    float3                  _lightLocationView;

    // Must be equal: 1.0F / units-per-meter
    float                   _sceneScaleFactor;

    half3                   _hue;
    half                    _intensity;

    float2                  _padding1_0;
};

struct InputData
{
    linear float4           _pixel:         SV_Position;
};

struct OutputData
{
    [[vk::location (0)]]
    float4                  _color:         SV_Target0;
};

//----------------------------------------------------------------------------------------------------------------------

half3 GetDiffuseK ( in half3 fesnelFactor, in half metallic )
{
    return ( 1.0H - fesnelFactor ) * ( 1.0H - metallic );
}

half GetDirectK ( in half roughness )
{
    const half alpha = roughness + 1.0H;
    return alpha * alpha * 0.125H;
}

half GGXSchlick ( in half dotFactor, in half k )
{
    return dotFactor / mad ( dotFactor, 1.0H - k, k );
}

half3 GetAlbedo ()
{
    return (half3)g_albedo.SubpassLoad ().xyz;
}

half GetAttenuation ( in float3 fragToLight )
{
    const half beta = (half)max ( 1.0F, _sceneScaleFactor * length ( fragToLight ) );
    return _intensity / ( beta * beta );
}

float GetDepth ()
{
    return g_depth.SubpassLoad ();
}

half GetDistribution ( in half nH, in half roughness )
{
    const half alpha = roughness * roughness;
    const half beta = alpha * alpha;
    const half gamma = nH * nH;
    const half zeta = mad ( gamma, beta - 1.0H, 1.0H );

    return beta / ( PI * zeta * zeta );
}

half3 GetFresnel ( in half nH, in half metallic, in half3 albedo )
{
    const half3 f0 = lerp ( (half3)MINIMUM_F0, albedo, (half3)metallic );
    return mad ( 1.0H - f0, pow ( max ( 0.0H, 1.0H - nH ), 5.0H ), f0 );
}

half GetGeometryAttenuation ( in half nL, in half nV, in half roughness )
{
    const half k = GetDirectK ( roughness );
    return GGXSchlick ( nL, k ) * GGXSchlick ( nV, k );
}

void GetParams ( out half roughness, out half metallic )
{
    const half4 paramSample = (half4)g_params.SubpassLoad ();
    roughness = paramSample.x;
    metallic = paramSample.z;
}

half GetShadowFactor ( in float3 locationView )
{
    const float3 dir = mul ( _viewToLight, float4 ( locationView, 1.0F ) ).xyz * SHADOW_MAP_BIAS;
    const float3 faceSelector = abs ( dir );
    const float z = max ( faceSelector.x, max ( faceSelector.y, faceSelector.z ) );
    const float4 cvv = mul ( _lightProjection, float4 ( 0.0F, 0.0F, z, 1.0F ) );

    return (half)g_shadowmap.SampleCmpLevelZero ( g_sampler, dir, cvv.z / cvv.w );
}

float3 RestoreLocationView ( in float2 locationImage )
{
    const float2 alpha = mad ( locationImage, _invResolutionFactor, (float2)( -1.0F ) );
    const float4 v = mul ( _cvvToView, float4 ( alpha, GetDepth (), 1.0F ) );
    return v.xyz * ( 1.0F / v.w );
}

half3 RestoreNormalView ()
{
    const half3 alpha = (half3)g_normal.SubpassLoad ().xyz;
    return mad ( alpha, (half3)2.0H, (half3)( -1.0H ) );
}

//----------------------------------------------------------------------------------------------------------------------

OutputData PS ( in InputData inputData )
{
    const float3 locationView = RestoreLocationView ( inputData._pixel.xy );
    const float3 fragToLight = _lightLocationView - locationView;

    const half attenuation = GetAttenuation ( fragToLight );
    const half3 toViewerView = -normalize ( (half3)locationView );
    const half3 toLightView = normalize ( (half3)fragToLight );
    const half3 halfVectorView = normalize ( toLightView + toViewerView );
    const half3 normalView = RestoreNormalView ();

    half roughness;
    half metallic;
    GetParams ( roughness, metallic );

    const half3 albedo = GetAlbedo ();

    const half nL = max ( 0.0H, dot ( normalView, toLightView ) );
    const half nH = max ( 0.0H, dot ( normalView, halfVectorView ) );
    const half nV = max ( 0.0H, dot ( normalView, toViewerView ) );

    const half d = GetDistribution ( nH, roughness );
    const half3 f = GetFresnel ( nH, metallic, albedo );
    const half ga = GetGeometryAttenuation ( nL, nV, roughness );
    const half shadow = GetShadowFactor ( locationView );
    const half3 kD = GetDiffuseK ( f, metallic );

    const half3 specular = f * d * ga / ( max ( EPSILON, 4.0H * nL * nV ) );
    const half3 color = shadow * nL * attenuation * _hue * mad ( kD * albedo, INVERSE_PI, specular );

    OutputData result;
    result._color = float4 ( (float3)color, 1.0F );

    return result;
}
