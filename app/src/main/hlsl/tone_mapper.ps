#include "full_screen_triangle.inc"
#include "tone_mapper.inc"


// 1.0H / 2.4H
#define INVERSE_GAMMA           4.16667e-1H

[[vk::binding ( BIND_HDR_IMAGE, SET_RESOURCE )]]
Texture2D<float32_t4>           g_hdrImage:         register ( t0 );

[[vk::binding ( BIND_POINT_SAMPLER, SET_RESOURCE )]]
SamplerState                    g_pointSampler:     register ( s0 );

[[vk::binding ( BIND_EXPOSURE, SET_RESOURCE )]]
cbuffer Exposure:                                   register ( b0 )
{
    float32_t                   g_exposure;
}

struct InputData
{
    [[vk::location ( ATT_SLOT_UV )]]
    noperspective float32_t2    _uv:                UV;
};

//----------------------------------------------------------------------------------------------------------------------

float16_t3 ApplyACES ( in float32_t2 uv )
{
    // See https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
    float16_t3 const hdr = (float16_t3)g_hdrImage.SampleLevel ( g_pointSampler, uv, 0.0F ).xyz;
    float16_t3 const raw = (float16_t3)g_exposure * hdr;

    float16_t3 const alpha = mad ( (float16_t3)2.51H, raw, (float16_t3)0.03H );
    float16_t3 const beta = mad ( (float16_t3)2.43H, raw, (float16_t3)0.59H );
    return min ( 1.0H, ( raw * alpha ) / mad ( raw, beta, (float16_t3)0.14H ) );
}

float32_t4 LinearToSRGB ( in float16_t3 ldr )
{
    // See https://entropymine.com/imageworsener/srgbformula/
    float16_t3 const a = ldr * 12.92H;
    float16_t3 const b = 1.055H * pow ( ldr, INVERSE_GAMMA ) - 0.055H;
    return float32_t4 ( (float32_t3)lerp ( a, b, (float16_t3)( ldr > 3.1308e-3H ) ), 1.0F );
}

//----------------------------------------------------------------------------------------------------------------------

float32_t4 PS ( in InputData inputData ): SV_Target0
{
    return LinearToSRGB ( ApplyACES ( inputData._uv ) );
}
