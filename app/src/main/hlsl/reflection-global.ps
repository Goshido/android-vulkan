
#define PREFILTER_MAX_MIP_LEVEL     8.0F

[[vk::binding ( 1, 0 )]]
[[vk::input_attachment_index (1)]]
SubpassInput<float4>        g_normal;

[[vk::binding ( 2, 0 )]]
[[vk::input_attachment_index (2)]]
SubpassInput<float4>        g_params;

[[vk::binding ( 3, 0 )]]
[[vk::input_attachment_index (3)]]
SubpassInput<float>         g_depth;

[[vk::binding ( 4, 0 )]]
cbuffer ViewData:                           register ( b0 )
{
    matrix                  _cvvToView;

    // Optimiztion:
    // must be equal: 2.0F / resolution.
    float2                  _invResolutionFactor;
    float2                  _padding0_0;
};

[[vk::binding ( 0, 1 )]]
TextureCube<float4>         g_prefilter:    register ( t0 );

[[vk::binding ( 1, 1 )]]
SamplerState                g_sampler:      register ( s0 );

[[vk::binding ( 2, 1 )]]
cbuffer LightData:                          register ( b1 )
{
    matrix                  _viewToWorld;
};

struct InputData
{
    linear float4           _pixel:         SV_Position;
};

struct OutputData
{
    [[vk::location (0)]]
    float4                  _color:         SV_Target0;
};

//----------------------------------------------------------------------------------------------------------------------

float GetDepth ()
{
    return g_depth.SubpassLoad ();
}

float3 RestoreDirectionView ( in float2 locationImage, in float depth )
{
    const float2 alpha = mad ( locationImage, _invResolutionFactor, (float2)( -1.0F ) );
    const float4 v = mul ( _cvvToView, float4 ( alpha, depth, 1.0F ) );
    return normalize ( v.xyz );
}

float3 RestoreNormalView ()
{
    const float3 alpha = g_normal.SubpassLoad ().xyz;
    return mad ( alpha, (float3)2.0F, (float3)( -1.0F ) );
}

float Roughness2Mip ()
{
    // It's emperical ease function. Please plot the graph to see what happens.
    // note abs is needed to mitigate X3571 error.

    const float r = g_params.SubpassLoad ().x;
    const float roughness = r * r;

    const float mip = 8.42F + ( 0.01F - 8.42F ) / ( 1.0F + pow ( abs ( roughness / 0.2584F ), 2.164F ) );
    return clamp ( mip, 0.0F, PREFILTER_MAX_MIP_LEVEL );
}

OutputData PS ( in InputData inputData )
{
    const float depth = GetDepth ();
    OutputData result;

    if ( depth == 1.0F )
    {
        result._color = (float4)0.0F;
        discard;
        return result;
    }

    const float3 directionView = RestoreDirectionView ( inputData._pixel.xy, depth );
    const float3 normalView = RestoreNormalView ();
    const float3 refl = -mul ( (float3x3)_viewToWorld, reflect ( directionView, normalView ) );

    result._color = float4 ( g_prefilter.SampleLevel ( g_sampler, refl, Roughness2Mip () ).xyz, 0.0F );
    return result;
}
