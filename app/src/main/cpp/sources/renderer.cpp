#include <renderer.h>
#include <cassert>
#include <cinttypes>
#include <cmath>
#include <string>
#include "vulkan_utils.h"


namespace android_vulkan {

constexpr static const char* APPLICATION_NAME = "android vulkan";
constexpr static const char* ENGINE_NAME = "renderer";
constexpr static const char* INDENT_1 = "    ";
constexpr static const char* INDENT_2 = "        ";
constexpr static const char* INDENT_3 = "            ";
constexpr static const size_t INITIAL_EXTENSION_STORAGE_SIZE = 64U;
constexpr static const uint32_t TARGET_VULKAN_VERSION = VK_MAKE_VERSION ( 1, 1, 108 );
constexpr static const char* UNKNOWN_RESULT = "UNKNOWN";

//----------------------------------------------------------------------------------------------------------------------

constexpr static const std::pair<uint32_t, const char*> g_vkCompositeAlphaFlagBitsKHRMapper[] =
{
    { static_cast<uint32_t> ( VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR ), "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR" },
    { static_cast<uint32_t> ( VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR ), "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR" },

    {
        static_cast<uint32_t> ( VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR ),
        "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"
    },

    {
        static_cast<uint32_t> ( VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR ),
        "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"
    }
};

constexpr static const size_t g_vkCompositeAlphaFlagBitsKHRMapperItems =
    sizeof ( g_vkCompositeAlphaFlagBitsKHRMapper ) / sizeof ( g_vkCompositeAlphaFlagBitsKHRMapper[ 0U ] );

constexpr static const std::pair<uint32_t, const char*> g_vkMemoryHeapFlagBitsMapper[] =
{
    { static_cast<uint32_t> ( VK_MEMORY_HEAP_DEVICE_LOCAL_BIT ), "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT" },
    { static_cast<uint32_t> ( VK_MEMORY_HEAP_MULTI_INSTANCE_BIT ), "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" }
};

constexpr static const size_t g_vkMemoryHeapFlagBitsMapperItems =
    sizeof ( g_vkMemoryHeapFlagBitsMapper ) / sizeof ( g_vkMemoryHeapFlagBitsMapper[ 0U ] );

constexpr static const std::pair<uint32_t, const char*> g_vkMemoryPropertyFlagBitsMapper[] =
{
    { static_cast<uint32_t> ( VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ), "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT" },
    { static_cast<uint32_t> ( VK_MEMORY_PROPERTY_HOST_CACHED_BIT ), "VK_MEMORY_PROPERTY_HOST_CACHED_BIT" },
    { static_cast<uint32_t> ( VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ), "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT" },
    { static_cast<uint32_t> ( VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ), "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT" },
    { static_cast<uint32_t> ( VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT ), "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT" },
    { static_cast<uint32_t> ( VK_MEMORY_PROPERTY_PROTECTED_BIT ), "VK_MEMORY_PROPERTY_PROTECTED_BIT" },

    {
        static_cast<uint32_t> ( VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD ),
        "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"
    },

    {
        static_cast<uint32_t> ( VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD ),
        "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"
    }
};

constexpr static const size_t g_vkMemoryPropertyFlagBitsMapperItems =
    sizeof ( g_vkMemoryPropertyFlagBitsMapper ) / sizeof ( g_vkMemoryPropertyFlagBitsMapper[ 0U ] );

constexpr static const std::pair<uint32_t, const char*> g_vkImageUsageFlagBitsMapper[] =
{
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT ), "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT ), "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_SAMPLED_BIT ), "VK_IMAGE_USAGE_SAMPLED_BIT" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV ), "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_STORAGE_BIT ), "VK_IMAGE_USAGE_STORAGE_BIT" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_TRANSFER_DST_BIT ), "VK_IMAGE_USAGE_TRANSFER_DST_BIT" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_TRANSFER_SRC_BIT ), "VK_IMAGE_USAGE_TRANSFER_SRC_BIT" },
    { static_cast<uint32_t> ( VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT ), "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT" },

    {
        static_cast<uint32_t> ( VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ),
        "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"
    },

    {
        static_cast<uint32_t> ( VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT ),
        "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"
    }
};

constexpr static const size_t g_vkImageUsageFlagBitsMapperItems =
    sizeof ( g_vkImageUsageFlagBitsMapper ) / sizeof ( g_vkImageUsageFlagBitsMapper[ 0U ] );

constexpr static const std::pair<uint32_t, const char*> g_vkSampleCountFlagMapper[] =
{
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_1_BIT ), "VK_SAMPLE_COUNT_1_BIT" },
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_2_BIT ), "VK_SAMPLE_COUNT_2_BIT" },
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_4_BIT ), "VK_SAMPLE_COUNT_4_BIT" },
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_8_BIT ), "VK_SAMPLE_COUNT_8_BIT" },
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_16_BIT ), "VK_SAMPLE_COUNT_16_BIT" },
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_32_BIT ), "VK_SAMPLE_COUNT_32_BIT" },
    { static_cast<uint32_t> ( VK_SAMPLE_COUNT_64_BIT ), "VK_SAMPLE_COUNT_64_BIT" }
};

constexpr static const size_t g_vkSampleCountFlagMapperItems =
    sizeof ( g_vkSampleCountFlagMapper ) / sizeof ( g_vkSampleCountFlagMapper[ 0U ] );

constexpr static const std::pair<uint32_t, const char*> g_vkQueueFlagMapper[] =
{
    { static_cast<uint32_t> ( VK_QUEUE_COMPUTE_BIT ), "VK_QUEUE_COMPUTE_BIT" },
    { static_cast<uint32_t> ( VK_QUEUE_GRAPHICS_BIT ), "VK_QUEUE_GRAPHICS_BIT" },
    { static_cast<uint32_t> ( VK_QUEUE_PROTECTED_BIT ), "VK_QUEUE_PROTECTED_BIT" },
    { static_cast<uint32_t> ( VK_QUEUE_SPARSE_BINDING_BIT ), "VK_QUEUE_SPARSE_BINDING_BIT" },
    { static_cast<uint32_t> ( VK_QUEUE_TRANSFER_BIT ), "VK_QUEUE_TRANSFER_BIT" }
};

constexpr static const size_t g_vkQueueFlagMapperItems =
    sizeof ( g_vkQueueFlagMapper ) / sizeof ( g_vkQueueFlagMapper[ 0U ] );

constexpr static const std::pair<uint32_t, const char*> g_vkSurfaceTransformFlagBitsKHRMapper[] =
{
    { VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR" },
    { VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR" },
    { VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR, "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR" },
    { VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR" },
    { VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR, "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR" },
    { VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR" },

    {
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
        "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"
    },

    {
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
        "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"
    },

    {
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
        "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"
    }
};

constexpr static const size_t g_vkSurfaceTransformFlagBitsKHRMapperItems =
    sizeof ( g_vkSurfaceTransformFlagBitsKHRMapper ) / sizeof ( g_vkSurfaceTransformFlagBitsKHRMapper[ 0U ] );

// Kung-Fu: used in Renderer::PrintPhysicalDeviceGroupInfo to print physical device features.
constexpr static const std::pair<size_t, const char*> g_vkFeatureMap[] =
{
    { offsetof ( VkPhysicalDeviceFeatures, alphaToOne ), "alphaToOne" },
    { offsetof ( VkPhysicalDeviceFeatures, depthBiasClamp ), "depthBiasClamp" },
    { offsetof ( VkPhysicalDeviceFeatures, depthBounds ), "depthBounds" },
    { offsetof ( VkPhysicalDeviceFeatures, depthClamp ), "depthClamp" },
    { offsetof ( VkPhysicalDeviceFeatures, drawIndirectFirstInstance ), "drawIndirectFirstInstance" },
    { offsetof ( VkPhysicalDeviceFeatures, dualSrcBlend ), "dualSrcBlend" },
    { offsetof ( VkPhysicalDeviceFeatures, fillModeNonSolid ), "fillModeNonSolid" },
    { offsetof ( VkPhysicalDeviceFeatures, fragmentStoresAndAtomics ), "fragmentStoresAndAtomics" },
    { offsetof ( VkPhysicalDeviceFeatures, fullDrawIndexUint32 ), "fullDrawIndexUint32" },
    { offsetof ( VkPhysicalDeviceFeatures, geometryShader ), "geometryShader" },
    { offsetof ( VkPhysicalDeviceFeatures, imageCubeArray ), "imageCubeArray" },
    { offsetof ( VkPhysicalDeviceFeatures, independentBlend ), "independentBlend" },
    { offsetof ( VkPhysicalDeviceFeatures, inheritedQueries ), "inheritedQueries" },
    { offsetof ( VkPhysicalDeviceFeatures, largePoints ), "largePoints" },
    { offsetof ( VkPhysicalDeviceFeatures, logicOp ), "logicOp" },
    { offsetof ( VkPhysicalDeviceFeatures, multiDrawIndirect ), "multiDrawIndirect" },
    { offsetof ( VkPhysicalDeviceFeatures, multiViewport ), "multiViewport" },
    { offsetof ( VkPhysicalDeviceFeatures, occlusionQueryPrecise ), "occlusionQueryPrecise" },
    { offsetof ( VkPhysicalDeviceFeatures, pipelineStatisticsQuery ), "pipelineStatisticsQuery" },
    { offsetof ( VkPhysicalDeviceFeatures, robustBufferAccess ), "robustBufferAccess" },
    { offsetof ( VkPhysicalDeviceFeatures, sampleRateShading ), "sampleRateShading" },
    { offsetof ( VkPhysicalDeviceFeatures, samplerAnisotropy ), "samplerAnisotropy" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderClipDistance ), "shaderClipDistance" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderCullDistance ), "shaderCullDistance" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderFloat64 ), "shaderFloat64" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderImageGatherExtended ), "shaderImageGatherExtended" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderInt16 ), "shaderInt16" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderInt64 ), "shaderInt64" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderResourceMinLod ), "shaderResourceMinLod" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderResourceResidency ), "shaderResourceResidency" },
    { offsetof ( VkPhysicalDeviceFeatures, shaderStorageImageMultisample ), "shaderStorageImageMultisample" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseBinding ), "sparseBinding" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidency16Samples ), "sparseResidency16Samples" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidency2Samples ), "sparseResidency2Samples" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidency4Samples ), "sparseResidency4Samples" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidency8Samples ), "sparseResidency8Samples" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidencyAliased ), "sparseResidencyAliased" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidencyBuffer ), "sparseResidencyBuffer" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidencyImage2D ), "sparseResidencyImage2D" },
    { offsetof ( VkPhysicalDeviceFeatures, sparseResidencyImage3D ), "sparseResidencyImage3D" },
    { offsetof ( VkPhysicalDeviceFeatures, tessellationShader ), "tessellationShader" },
    { offsetof ( VkPhysicalDeviceFeatures, textureCompressionASTC_LDR ), "textureCompressionASTC_LDR" },
    { offsetof ( VkPhysicalDeviceFeatures, textureCompressionBC ), "textureCompressionBC" },
    { offsetof ( VkPhysicalDeviceFeatures, textureCompressionETC2 ), "textureCompressionETC2" },
    { offsetof ( VkPhysicalDeviceFeatures, variableMultisampleRate ), "variableMultisampleRate" },
    { offsetof ( VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics ), "vertexPipelineStoresAndAtomics" },
    { offsetof ( VkPhysicalDeviceFeatures, wideLines ), "wideLines" },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize ),
        "shaderTessellationAndGeometryPointSize"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats ),
        "shaderStorageImageExtendedFormats"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat ),
        "shaderStorageImageReadWithoutFormat"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat ),
        "shaderStorageImageWriteWithoutFormat"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing ),
        "shaderUniformBufferArrayDynamicIndexing"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing ),
        "shaderSampledImageArrayDynamicIndexing"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing ),
        "shaderStorageBufferArrayDynamicIndexing"
    },

    {
        offsetof ( VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing ),
        "shaderStorageImageArrayDynamicIndexing"
    }
};

//----------------------------------------------------------------------------------------------------------------------

VulkanPhysicalDeviceInfo::VulkanPhysicalDeviceInfo ():
    _extensionStorage ( INITIAL_EXTENSION_STORAGE_SIZE )
{
    // NOTHING
}

//----------------------------------------------------------------------------------------------------------------------

const std::map<VkColorSpaceKHR, const char*> Renderer::_vulkanColorSpaceMap =
{
    { VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT, "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT" },
    { VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT, "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT" },
    { VK_COLOR_SPACE_BT2020_LINEAR_EXT, "VK_COLOR_SPACE_BT2020_LINEAR_EXT" },
    { VK_COLOR_SPACE_BT709_LINEAR_EXT, "VK_COLOR_SPACE_BT709_LINEAR_EXT" },
    { VK_COLOR_SPACE_BT709_NONLINEAR_EXT, "VK_COLOR_SPACE_BT709_NONLINEAR_EXT" },
    { VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT, "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT" },
    { VK_COLOR_SPACE_DISPLAY_NATIVE_AMD, "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD" },
    { VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT, "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" },
    { VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT, "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT" },
    { VK_COLOR_SPACE_DOLBYVISION_EXT, "VK_COLOR_SPACE_DOLBYVISION_EXT" },
    { VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT, "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT" },
    { VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT, "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT" },
    { VK_COLOR_SPACE_HDR10_HLG_EXT, "VK_COLOR_SPACE_HDR10_HLG_EXT" },
    { VK_COLOR_SPACE_HDR10_ST2084_EXT, "VK_COLOR_SPACE_HDR10_ST2084_EXT" },
    { VK_COLOR_SPACE_PASS_THROUGH_EXT, "VK_COLOR_SPACE_PASS_THROUGH_EXT" },
    { VK_COLOR_SPACE_SRGB_NONLINEAR_KHR, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" }
};

const std::map<VkFormat, const char*> Renderer::_vulkanFormatMap =
{
    { VK_FORMAT_A1R5G5B5_UNORM_PACK16, "VK_FORMAT_A1R5G5B5_UNORM_PACK16" },
    { VK_FORMAT_A2B10G10R10_SINT_PACK32, "VK_FORMAT_A2B10G10R10_SINT_PACK32" },
    { VK_FORMAT_A2B10G10R10_SNORM_PACK32, "VK_FORMAT_A2B10G10R10_SNORM_PACK32" },
    { VK_FORMAT_A2B10G10R10_SSCALED_PACK32, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32" },
    { VK_FORMAT_A2B10G10R10_UINT_PACK32, "VK_FORMAT_A2B10G10R10_UINT_PACK32" },
    { VK_FORMAT_A2B10G10R10_UNORM_PACK32, "VK_FORMAT_A2B10G10R10_UNORM_PACK32" },
    { VK_FORMAT_A2B10G10R10_USCALED_PACK32, "VK_FORMAT_A2B10G10R10_USCALED_PACK32" },
    { VK_FORMAT_A2R10G10B10_SINT_PACK32, "VK_FORMAT_A2R10G10B10_SINT_PACK32" },
    { VK_FORMAT_A2R10G10B10_SNORM_PACK32, "VK_FORMAT_A2R10G10B10_SNORM_PACK32" },
    { VK_FORMAT_A2R10G10B10_SSCALED_PACK32, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32" },
    { VK_FORMAT_A2R10G10B10_UINT_PACK32, "VK_FORMAT_A2R10G10B10_UINT_PACK32" },
    { VK_FORMAT_A2R10G10B10_UNORM_PACK32, "VK_FORMAT_A2R10G10B10_UNORM_PACK32" },
    { VK_FORMAT_A2R10G10B10_USCALED_PACK32, "VK_FORMAT_A2R10G10B10_USCALED_PACK32" },
    { VK_FORMAT_A8B8G8R8_SINT_PACK32, "VK_FORMAT_A8B8G8R8_SINT_PACK32" },
    { VK_FORMAT_A8B8G8R8_SNORM_PACK32, "VK_FORMAT_A8B8G8R8_SNORM_PACK32" },
    { VK_FORMAT_A8B8G8R8_SRGB_PACK32, "VK_FORMAT_A8B8G8R8_SRGB_PACK32" },
    { VK_FORMAT_A8B8G8R8_SSCALED_PACK32, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32" },
    { VK_FORMAT_A8B8G8R8_UINT_PACK32, "VK_FORMAT_A8B8G8R8_UINT_PACK32" },
    { VK_FORMAT_A8B8G8R8_UNORM_PACK32, "VK_FORMAT_A8B8G8R8_UNORM_PACK32" },
    { VK_FORMAT_A8B8G8R8_USCALED_PACK32, "VK_FORMAT_A8B8G8R8_USCALED_PACK32" },
    { VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_10x10_SRGB_BLOCK, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_10x10_UNORM_BLOCK, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_10x5_SRGB_BLOCK, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_10x5_UNORM_BLOCK, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_10x6_SRGB_BLOCK, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_10x6_UNORM_BLOCK, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_10x8_SRGB_BLOCK, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_10x8_UNORM_BLOCK, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_12x10_SRGB_BLOCK, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_12x10_UNORM_BLOCK, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_12x12_SRGB_BLOCK, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_12x12_UNORM_BLOCK, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_4x4_SRGB_BLOCK, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_4x4_UNORM_BLOCK, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_5x4_SRGB_BLOCK, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_5x4_UNORM_BLOCK, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_5x5_SRGB_BLOCK, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_5x5_UNORM_BLOCK, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_6x5_SRGB_BLOCK, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_6x5_UNORM_BLOCK, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_6x6_SRGB_BLOCK, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_6x6_UNORM_BLOCK, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_8x5_SRGB_BLOCK, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_8x5_UNORM_BLOCK, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_8x6_SRGB_BLOCK, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_8x6_UNORM_BLOCK, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK" },
    { VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT, "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT" },
    { VK_FORMAT_ASTC_8x8_SRGB_BLOCK, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK" },
    { VK_FORMAT_ASTC_8x8_UNORM_BLOCK, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK" },
    { VK_FORMAT_B10G11R11_UFLOAT_PACK32, "VK_FORMAT_B10G11R11_UFLOAT_PACK32" },
    { VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16, "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16" },
    { VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16, "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16" },
    { VK_FORMAT_B16G16R16G16_422_UNORM, "VK_FORMAT_B16G16R16G16_422_UNORM" },
    { VK_FORMAT_B4G4R4A4_UNORM_PACK16, "VK_FORMAT_B4G4R4A4_UNORM_PACK16" },
    { VK_FORMAT_B5G5R5A1_UNORM_PACK16, "VK_FORMAT_B5G5R5A1_UNORM_PACK16" },
    { VK_FORMAT_B5G6R5_UNORM_PACK16, "VK_FORMAT_B5G6R5_UNORM_PACK16" },
    { VK_FORMAT_B8G8R8A8_SINT, "VK_FORMAT_B8G8R8A8_SINT" },
    { VK_FORMAT_B8G8R8A8_SNORM, "VK_FORMAT_B8G8R8A8_SNORM" },
    { VK_FORMAT_B8G8R8A8_SRGB, "VK_FORMAT_B8G8R8A8_SRGB" },
    { VK_FORMAT_B8G8R8A8_SSCALED, "VK_FORMAT_B8G8R8A8_SSCALED" },
    { VK_FORMAT_B8G8R8A8_UINT, "VK_FORMAT_B8G8R8A8_UINT" },
    { VK_FORMAT_B8G8R8A8_UNORM, "VK_FORMAT_B8G8R8A8_UNORM" },
    { VK_FORMAT_B8G8R8A8_USCALED, "VK_FORMAT_B8G8R8A8_USCALED" },
    { VK_FORMAT_B8G8R8G8_422_UNORM, "VK_FORMAT_B8G8R8G8_422_UNORM" },
    { VK_FORMAT_B8G8R8_SINT, "VK_FORMAT_B8G8R8_SINT" },
    { VK_FORMAT_B8G8R8_SNORM, "VK_FORMAT_B8G8R8_SNORM" },
    { VK_FORMAT_B8G8R8_SRGB, "VK_FORMAT_B8G8R8_SRGB" },
    { VK_FORMAT_B8G8R8_SSCALED, "VK_FORMAT_B8G8R8_SSCALED" },
    { VK_FORMAT_B8G8R8_UINT, "VK_FORMAT_B8G8R8_UINT" },
    { VK_FORMAT_B8G8R8_UNORM, "VK_FORMAT_B8G8R8_UNORM" },
    { VK_FORMAT_B8G8R8_USCALED, "VK_FORMAT_B8G8R8_USCALED" },
    { VK_FORMAT_BC1_RGBA_SRGB_BLOCK, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK" },
    { VK_FORMAT_BC1_RGBA_UNORM_BLOCK, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK" },
    { VK_FORMAT_BC1_RGB_SRGB_BLOCK, "VK_FORMAT_BC1_RGB_SRGB_BLOCK" },
    { VK_FORMAT_BC1_RGB_UNORM_BLOCK, "VK_FORMAT_BC1_RGB_UNORM_BLOCK" },
    { VK_FORMAT_BC2_SRGB_BLOCK, "VK_FORMAT_BC2_SRGB_BLOCK" },
    { VK_FORMAT_BC2_UNORM_BLOCK, "VK_FORMAT_BC2_UNORM_BLOCK" },
    { VK_FORMAT_BC3_SRGB_BLOCK, "VK_FORMAT_BC3_SRGB_BLOCK" },
    { VK_FORMAT_BC3_UNORM_BLOCK, "VK_FORMAT_BC3_UNORM_BLOCK" },
    { VK_FORMAT_BC4_SNORM_BLOCK, "VK_FORMAT_BC4_SNORM_BLOCK" },
    { VK_FORMAT_BC4_UNORM_BLOCK, "VK_FORMAT_BC4_UNORM_BLOCK" },
    { VK_FORMAT_BC5_SNORM_BLOCK, "VK_FORMAT_BC5_SNORM_BLOCK" },
    { VK_FORMAT_BC5_UNORM_BLOCK, "VK_FORMAT_BC5_UNORM_BLOCK" },
    { VK_FORMAT_BC6H_SFLOAT_BLOCK, "VK_FORMAT_BC6H_SFLOAT_BLOCK" },
    { VK_FORMAT_BC6H_UFLOAT_BLOCK, "VK_FORMAT_BC6H_UFLOAT_BLOCK" },
    { VK_FORMAT_BC7_SRGB_BLOCK, "VK_FORMAT_BC7_SRGB_BLOCK" },
    { VK_FORMAT_BC7_UNORM_BLOCK, "VK_FORMAT_BC7_UNORM_BLOCK" },
    { VK_FORMAT_D16_UNORM, "VK_FORMAT_D16_UNORM" },
    { VK_FORMAT_D16_UNORM_S8_UINT, "VK_FORMAT_D16_UNORM_S8_UINT" },
    { VK_FORMAT_D24_UNORM_S8_UINT, "VK_FORMAT_D24_UNORM_S8_UINT" },
    { VK_FORMAT_D32_SFLOAT, "VK_FORMAT_D32_SFLOAT" },
    { VK_FORMAT_D32_SFLOAT_S8_UINT, "VK_FORMAT_D32_SFLOAT_S8_UINT" },
    { VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32" },
    { VK_FORMAT_EAC_R11G11_SNORM_BLOCK, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK" },
    { VK_FORMAT_EAC_R11G11_UNORM_BLOCK, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK" },
    { VK_FORMAT_EAC_R11_SNORM_BLOCK, "VK_FORMAT_EAC_R11_SNORM_BLOCK" },
    { VK_FORMAT_EAC_R11_UNORM_BLOCK, "VK_FORMAT_EAC_R11_UNORM_BLOCK" },
    { VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK" },
    { VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK" },
    { VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK" },
    { VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK" },
    { VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK" },
    { VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK" },
    { VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16, "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16" },
    { VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16" },
    { VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16" },
    { VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16" },
    { VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16" },
    { VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16, "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16" },
    { VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16, "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16" },
    { VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16" },
    { VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16" },
    { VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16" },
    { VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16" },
    { VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16, "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16" },
    { VK_FORMAT_G16B16G16R16_422_UNORM, "VK_FORMAT_G16B16G16R16_422_UNORM" },
    { VK_FORMAT_G16_B16R16_2PLANE_420_UNORM, "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM" },
    { VK_FORMAT_G16_B16R16_2PLANE_422_UNORM, "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM" },
    { VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM, "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM" },
    { VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM, "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM" },
    { VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM, "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM" },
    { VK_FORMAT_G8B8G8R8_422_UNORM, "VK_FORMAT_G8B8G8R8_422_UNORM" },
    { VK_FORMAT_G8_B8R8_2PLANE_420_UNORM, "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM" },
    { VK_FORMAT_G8_B8R8_2PLANE_422_UNORM, "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM" },
    { VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM" },
    { VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM, "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM" },
    { VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM, "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM" },
    { VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG" },
    { VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG" },
    { VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG" },
    { VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG" },
    { VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG" },
    { VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG" },
    { VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG, "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG" },
    { VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG, "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG" },
    { VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16, "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16" },
    { VK_FORMAT_R10X6G10X6_UNORM_2PACK16, "VK_FORMAT_R10X6G10X6_UNORM_2PACK16" },
    { VK_FORMAT_R10X6_UNORM_PACK16, "VK_FORMAT_R10X6_UNORM_PACK16" },
    { VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16, "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16" },
    { VK_FORMAT_R12X4G12X4_UNORM_2PACK16, "VK_FORMAT_R12X4G12X4_UNORM_2PACK16" },
    { VK_FORMAT_R12X4_UNORM_PACK16, "VK_FORMAT_R12X4_UNORM_PACK16" },
    { VK_FORMAT_R16G16B16A16_SFLOAT, "VK_FORMAT_R16G16B16A16_SFLOAT" },
    { VK_FORMAT_R16G16B16A16_SINT, "VK_FORMAT_R16G16B16A16_SINT" },
    { VK_FORMAT_R16G16B16A16_SNORM, "VK_FORMAT_R16G16B16A16_SNORM" },
    { VK_FORMAT_R16G16B16A16_SSCALED, "VK_FORMAT_R16G16B16A16_SSCALED" },
    { VK_FORMAT_R16G16B16A16_UINT, "VK_FORMAT_R16G16B16A16_UINT" },
    { VK_FORMAT_R16G16B16A16_UNORM, "VK_FORMAT_R16G16B16A16_UNORM" },
    { VK_FORMAT_R16G16B16A16_USCALED, "VK_FORMAT_R16G16B16A16_USCALED" },
    { VK_FORMAT_R16G16B16_SFLOAT, "VK_FORMAT_R16G16B16_SFLOAT" },
    { VK_FORMAT_R16G16B16_SINT, "VK_FORMAT_R16G16B16_SINT" },
    { VK_FORMAT_R16G16B16_SNORM, "VK_FORMAT_R16G16B16_SNORM" },
    { VK_FORMAT_R16G16B16_SSCALED, "VK_FORMAT_R16G16B16_SSCALED" },
    { VK_FORMAT_R16G16B16_UINT, "VK_FORMAT_R16G16B16_UINT" },
    { VK_FORMAT_R16G16B16_UNORM, "VK_FORMAT_R16G16B16_UNORM" },
    { VK_FORMAT_R16G16B16_USCALED, "VK_FORMAT_R16G16B16_USCALED" },
    { VK_FORMAT_R16G16_SFLOAT, "VK_FORMAT_R16G16_SFLOAT" },
    { VK_FORMAT_R16G16_SINT, "VK_FORMAT_R16G16_SINT" },
    { VK_FORMAT_R16G16_SNORM, "VK_FORMAT_R16G16_SNORM" },
    { VK_FORMAT_R16G16_SSCALED, "VK_FORMAT_R16G16_SSCALED" },
    { VK_FORMAT_R16G16_UINT, "VK_FORMAT_R16G16_UINT" },
    { VK_FORMAT_R16G16_UNORM, "VK_FORMAT_R16G16_UNORM" },
    { VK_FORMAT_R16G16_USCALED, "VK_FORMAT_R16G16_USCALED" },
    { VK_FORMAT_R16_SFLOAT, "VK_FORMAT_R16_SFLOAT" },
    { VK_FORMAT_R16_SINT, "VK_FORMAT_R16_SINT" },
    { VK_FORMAT_R16_SNORM, "VK_FORMAT_R16_SNORM" },
    { VK_FORMAT_R16_SSCALED, "VK_FORMAT_R16_SSCALED" },
    { VK_FORMAT_R16_UINT, "VK_FORMAT_R16_UINT" },
    { VK_FORMAT_R16_UNORM, "VK_FORMAT_R16_UNORM" },
    { VK_FORMAT_R16_USCALED, "VK_FORMAT_R16_USCALED" },
    { VK_FORMAT_R32G32B32A32_SFLOAT, "VK_FORMAT_R32G32B32A32_SFLOAT" },
    { VK_FORMAT_R32G32B32A32_SINT, "VK_FORMAT_R32G32B32A32_SINT" },
    { VK_FORMAT_R32G32B32A32_UINT, "VK_FORMAT_R32G32B32A32_UINT" },
    { VK_FORMAT_R32G32B32_SFLOAT, "VK_FORMAT_R32G32B32_SFLOAT" },
    { VK_FORMAT_R32G32B32_SINT, "VK_FORMAT_R32G32B32_SINT" },
    { VK_FORMAT_R32G32B32_UINT, "VK_FORMAT_R32G32B32_UINT" },
    { VK_FORMAT_R32G32_SFLOAT, "VK_FORMAT_R32G32_SFLOAT" },
    { VK_FORMAT_R32G32_SINT, "VK_FORMAT_R32G32_SINT" },
    { VK_FORMAT_R32G32_UINT, "VK_FORMAT_R32G32_UINT" },
    { VK_FORMAT_R32_SFLOAT, "VK_FORMAT_R32_SFLOAT" },
    { VK_FORMAT_R32_SINT, "VK_FORMAT_R32_SINT" },
    { VK_FORMAT_R32_UINT, "VK_FORMAT_R32_UINT" },
    { VK_FORMAT_R4G4B4A4_UNORM_PACK16, "VK_FORMAT_R4G4B4A4_UNORM_PACK16" },
    { VK_FORMAT_R4G4_UNORM_PACK8, "VK_FORMAT_R4G4_UNORM_PACK8" },
    { VK_FORMAT_R5G5B5A1_UNORM_PACK16, "VK_FORMAT_R5G5B5A1_UNORM_PACK16" },
    { VK_FORMAT_R5G6B5_UNORM_PACK16, "VK_FORMAT_R5G6B5_UNORM_PACK16" },
    { VK_FORMAT_R64G64B64A64_SFLOAT, "VK_FORMAT_R64G64B64A64_SFLOAT" },
    { VK_FORMAT_R64G64B64A64_SINT, "VK_FORMAT_R64G64B64A64_SINT" },
    { VK_FORMAT_R64G64B64A64_UINT, "VK_FORMAT_R64G64B64A64_UINT" },
    { VK_FORMAT_R64G64B64_SFLOAT, "VK_FORMAT_R64G64B64_SFLOAT" },
    { VK_FORMAT_R64G64B64_SINT, "VK_FORMAT_R64G64B64_SINT" },
    { VK_FORMAT_R64G64B64_UINT, "VK_FORMAT_R64G64B64_UINT" },
    { VK_FORMAT_R64G64_SFLOAT, "VK_FORMAT_R64G64_SFLOAT" },
    { VK_FORMAT_R64G64_SINT, "VK_FORMAT_R64G64_SINT" },
    { VK_FORMAT_R64G64_UINT, "VK_FORMAT_R64G64_UINT" },
    { VK_FORMAT_R64_SFLOAT, "VK_FORMAT_R64_SFLOAT" },
    { VK_FORMAT_R64_SINT, "VK_FORMAT_R64_SINT" },
    { VK_FORMAT_R64_UINT, "VK_FORMAT_R64_UINT" },
    { VK_FORMAT_R8G8B8A8_SINT, "VK_FORMAT_R8G8B8A8_SINT" },
    { VK_FORMAT_R8G8B8A8_SNORM, "VK_FORMAT_R8G8B8A8_SNORM" },
    { VK_FORMAT_R8G8B8A8_SRGB, "VK_FORMAT_R8G8B8A8_SRGB" },
    { VK_FORMAT_R8G8B8A8_SSCALED, "VK_FORMAT_R8G8B8A8_SSCALED" },
    { VK_FORMAT_R8G8B8A8_UINT, "VK_FORMAT_R8G8B8A8_UINT" },
    { VK_FORMAT_R8G8B8A8_UNORM, "VK_FORMAT_R8G8B8A8_UNORM" },
    { VK_FORMAT_R8G8B8A8_USCALED, "VK_FORMAT_R8G8B8A8_USCALED" },
    { VK_FORMAT_R8G8B8_SINT, "VK_FORMAT_R8G8B8_SINT" },
    { VK_FORMAT_R8G8B8_SNORM, "VK_FORMAT_R8G8B8_SNORM" },
    { VK_FORMAT_R8G8B8_SRGB, "VK_FORMAT_R8G8B8_SRGB" },
    { VK_FORMAT_R8G8B8_SSCALED, "VK_FORMAT_R8G8B8_SSCALED" },
    { VK_FORMAT_R8G8B8_UINT, "VK_FORMAT_R8G8B8_UINT" },
    { VK_FORMAT_R8G8B8_UNORM, "VK_FORMAT_R8G8B8_UNORM" },
    { VK_FORMAT_R8G8B8_USCALED, "VK_FORMAT_R8G8B8_USCALED" },
    { VK_FORMAT_R8G8_SINT, "VK_FORMAT_R8G8_SINT" },
    { VK_FORMAT_R8G8_SNORM, "VK_FORMAT_R8G8_SNORM" },
    { VK_FORMAT_R8G8_SRGB, "VK_FORMAT_R8G8_SRGB" },
    { VK_FORMAT_R8G8_SSCALED, "VK_FORMAT_R8G8_SSCALED" },
    { VK_FORMAT_R8G8_UINT, "VK_FORMAT_R8G8_UINT" },
    { VK_FORMAT_R8G8_UNORM, "VK_FORMAT_R8G8_UNORM" },
    { VK_FORMAT_R8G8_USCALED, "VK_FORMAT_R8G8_USCALED" },
    { VK_FORMAT_R8_SINT, "VK_FORMAT_R8_SINT" },
    { VK_FORMAT_R8_SNORM, "VK_FORMAT_R8_SNORM" },
    { VK_FORMAT_R8_SRGB, "VK_FORMAT_R8_SRGB" },
    { VK_FORMAT_R8_SSCALED, "VK_FORMAT_R8_SSCALED" },
    { VK_FORMAT_R8_UINT, "VK_FORMAT_R8_UINT" },
    { VK_FORMAT_R8_UNORM, "VK_FORMAT_R8_UNORM" },
    { VK_FORMAT_R8_USCALED, "VK_FORMAT_R8_USCALED" },
    { VK_FORMAT_S8_UINT, "VK_FORMAT_S8_UINT" },
    { VK_FORMAT_UNDEFINED, "VK_FORMAT_UNDEFINED" },
    { VK_FORMAT_X8_D24_UNORM_PACK32, "VK_FORMAT_X8_D24_UNORM_PACK32" }
};

const std::map<VkDebugReportObjectTypeEXT, const char*> Renderer::_vulkanObjectTypeMap =
{
    { VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT" },
    { VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT, "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" },

    {
        VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT,
        "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"
    },

    {
        VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
        "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"
    },

    {
        VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
        "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"
    },

    {
        VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT,
        "VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"
    },

    {
        VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
        "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"
    }
};

const std::map<VkPhysicalDeviceType, const char*> Renderer::_vulkanPhysicalDeviceTypeMap =
{
    { VK_PHYSICAL_DEVICE_TYPE_CPU, "VK_PHYSICAL_DEVICE_TYPE_CPU" },
    { VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU, "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU" },
    { VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU, "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU" },
    { VK_PHYSICAL_DEVICE_TYPE_OTHER, "VK_PHYSICAL_DEVICE_TYPE_OTHER" },
    { VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU, "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU" }
};

const std::map<VkPresentModeKHR, const char*> Renderer::_vulkanPresentModeMap =
{
    { VK_PRESENT_MODE_FIFO_KHR, "VK_PRESENT_MODE_FIFO_KHR" },
    { VK_PRESENT_MODE_FIFO_RELAXED_KHR, "VK_PRESENT_MODE_FIFO_RELAXED_KHR" },
    { VK_PRESENT_MODE_IMMEDIATE_KHR, "VK_PRESENT_MODE_IMMEDIATE_KHR" },
    { VK_PRESENT_MODE_MAILBOX_KHR, "VK_PRESENT_MODE_MAILBOX_KHR" },
    { VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR" },
    { VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR" }
};

const std::map<VkResult, const char*> Renderer::_vulkanResultMap =
{
    { VK_ERROR_DEVICE_LOST, "VK_ERROR_DEVICE_LOST" },
    { VK_ERROR_EXTENSION_NOT_PRESENT, "VK_ERROR_EXTENSION_NOT_PRESENT" },
    { VK_ERROR_FRAGMENTATION_EXT, "VK_ERROR_FRAGMENTATION_EXT" },
    { VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT, "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT" },
    { VK_ERROR_INCOMPATIBLE_DRIVER, "VK_ERROR_INCOMPATIBLE_DRIVER" },
    { VK_ERROR_INITIALIZATION_FAILED, "VK_ERROR_INITIALIZATION_FAILED" },
    { VK_ERROR_INVALID_EXTERNAL_HANDLE, "VK_ERROR_INVALID_EXTERNAL_HANDLE" },
    { VK_ERROR_INVALID_SHADER_NV, "VK_ERROR_INVALID_SHADER_NV" },
    { VK_ERROR_LAYER_NOT_PRESENT, "VK_ERROR_LAYER_NOT_PRESENT" },
    { VK_ERROR_MEMORY_MAP_FAILED, "VK_ERROR_MEMORY_MAP_FAILED" },
    { VK_ERROR_NATIVE_WINDOW_IN_USE_KHR, "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR" },
    { VK_ERROR_OUT_OF_DATE_KHR, "VK_ERROR_OUT_OF_DATE_KHR" },
    { VK_ERROR_OUT_OF_DEVICE_MEMORY, "VK_ERROR_OUT_OF_DEVICE_MEMORY" },
    { VK_ERROR_OUT_OF_HOST_MEMORY, "VK_ERROR_OUT_OF_HOST_MEMORY" },
    { VK_ERROR_SURFACE_LOST_KHR, "VK_ERROR_SURFACE_LOST_KHR" },
    { VK_ERROR_TOO_MANY_OBJECTS, "VK_ERROR_TOO_MANY_OBJECTS" },
    { VK_SUBOPTIMAL_KHR, "VK_SUBOPTIMAL_KHR" }
};

//----------------------------------------------------------------------------------------------------------------------

Renderer::Renderer ():
    _debugReportCallback ( VK_NULL_HANDLE ),
    _depthStencilImage ( VK_NULL_HANDLE ),
    _depthStencilImageFormat ( VK_FORMAT_UNDEFINED ),
    _depthStencilImageMemory (  VK_NULL_HANDLE ),
    _depthStencilImageView ( VK_NULL_HANDLE ),
    _device ( VK_NULL_HANDLE ),
    _instance ( VK_NULL_HANDLE ),
    _physicalDevice ( VK_NULL_HANDLE ),
    _queue ( VK_NULL_HANDLE ),
    _queueFamilyIndex ( VK_QUEUE_FAMILY_IGNORED ),
    _renderPass ( VK_NULL_HANDLE ),
    _surface ( VK_NULL_HANDLE ),
    _surfaceFormat ( VK_FORMAT_UNDEFINED ),
    _swapchain ( VK_NULL_HANDLE ),
    vkCreateDebugReportCallbackEXT ( nullptr ),
    vkDestroyDebugReportCallbackEXT ( nullptr )
{
    // NOTHING
}

bool Renderer::CheckVkResult ( VkResult result, const char* from, const char* message ) const
{
    if ( result == VK_SUCCESS )
        return true;

    LogError ( "Renderer::%s - %s. Error: %s.", from, message, ResolveVkResult ( result ) );
    assert ( false );
    return false;
}

VkFormat Renderer::GetDefaultDepthStencilFormat () const
{
    return _depthStencilImageFormat;
}

VkDevice Renderer::GetDevice () const
{
    return _device;
}

VkFramebuffer Renderer::GetPresentFramebuffer ( uint32_t framebufferIndex ) const
{
    return _presentFramebuffers[ framebufferIndex ];
}

size_t Renderer::GetPresentFramebufferCount () const
{
    return _presentFramebuffers.size ();
}

VkRenderPass Renderer::GetPresentRenderPass () const
{
    return _renderPass;
}

VkQueue Renderer::GetQueue () const
{
    return _queue;
}

uint32_t Renderer::GetQueueFamilyIndex () const
{
    return _queueFamilyIndex;
}

VkFormat Renderer::GetSurfaceFormat () const
{
    return _surfaceFormat;
}

const VkExtent2D& Renderer::GetSurfaceSize () const
{
    return _surfaceSize;
}

VkSwapchainKHR& Renderer::GetSwapchain ()
{
    return _swapchain;
}

bool Renderer::IsReady () const
{
    return _renderPass != VK_NULL_HANDLE;
}

bool Renderer::OnInit ( ANativeWindow &nativeWindow, bool vSync )
{
    if ( !InitVulkan () )
    {
        LogError ( "Renderer::OnInit - Can't init Vulkan backend." );
        assert ( !"Renderer::OnInit - Can't init Vulkan backend." );
        return false;
    }

    PrintInstanceLayerInfo ();

    DeployInstance ();
    DeployDebugFeatures ();

    uint32_t physicalDeviceCount = 0U;
    vkEnumeratePhysicalDevices ( _instance, &physicalDeviceCount, nullptr );

    if ( !physicalDeviceCount )
    {
        DestroyDebugFeatures ();
        DestroyInstance ();

        LogError ( "Renderer::OnInit - There is no any Vulkan physical device." );
        assert ( !"Renderer::OnInit - There is no any Vulkan physical device." );

        return false;
    }

    LogInfo ( "Renderer::OnInit - Vulkan physical devices detected: %u.", physicalDeviceCount );

    std::vector<VkPhysicalDevice> physicalDevices ( static_cast<size_t> ( physicalDeviceCount ) );
    VkPhysicalDevice* deviceList = physicalDevices.data ();

    bool result = CheckVkResult ( vkEnumeratePhysicalDevices ( _instance, &physicalDeviceCount, deviceList ),
        "Renderer::OnInit",
        "Can't get Vulkan physical devices"
    );

    if ( !result )
    {
        DestroyDebugFeatures ();
        DestroyInstance ();
        return false;
    }

    for ( uint32_t i = 0U; i < physicalDeviceCount; ++i )
    {
        if ( PrintPhysicalDeviceInfo ( i, deviceList[ i ] ) ) continue;

        _physicalDeviceInfo.clear ();
        DestroyDebugFeatures ();
        DestroyInstance ();

        return false;
    }

    uint32_t physicalDeviceGroupCount = 0U;
    vkEnumeratePhysicalDeviceGroups ( _instance, &physicalDeviceGroupCount, nullptr );

    if ( !physicalDeviceGroupCount )
    {
        _physicalDeviceInfo.clear ();
        DestroyDebugFeatures ();
        DestroyInstance ();

        LogError ( "Renderer::OnInit - There is no any Vulkan physical device groups." );
        assert ( !"Renderer::OnInit - There is no any Vulkan physical device groups." );

        return false;
    }

    LogInfo ( "Renderer::OnInit - Vulkan physical devices groups detected: %u.", physicalDeviceGroupCount );

    _physicalDeviceGroups.resize ( static_cast<size_t> ( physicalDeviceGroupCount ) );
    VkPhysicalDeviceGroupProperties* groupProps = _physicalDeviceGroups.data ();

    result = CheckVkResult ( vkEnumeratePhysicalDeviceGroups ( _instance, &physicalDeviceGroupCount, groupProps ),
        "Renderer::OnInit",
        "Can't get Vulkan physical device groups"
    );

    if ( !result )
    {
        _physicalDeviceGroups.clear ();
        _physicalDeviceInfo.clear ();

        DestroyDebugFeatures ();
        DestroyInstance ();

        return false;
    }

    for ( uint32_t i = 0U; i < physicalDeviceGroupCount; ++i )
        PrintPhysicalDeviceGroupInfo ( i, groupProps[ i ] );

    if ( !DeployDevice () )
    {
        _physicalDeviceGroups.clear ();
        _physicalDeviceInfo.clear ();

        DestroyDebugFeatures ();
        DestroyInstance ();

        return false;
    }

    if ( !DeploySurface ( nativeWindow ) )
    {
        _physicalDeviceGroups.clear ();
        _physicalDeviceInfo.clear ();

        DestroyDevice ();
        DestroyDebugFeatures ();
        DestroyInstance ();

        return false;
    }

    if ( !DeploySwapchain ( vSync ) )
    {
        _physicalDeviceGroups.clear ();
        _physicalDeviceInfo.clear ();

        DestroySurface ();
        DestroyDevice ();
        DestroyDebugFeatures ();
        DestroyInstance ();

        return false;
    }

    if ( !DeployRenderPass () )
    {
        _physicalDeviceGroups.clear ();
        _physicalDeviceInfo.clear ();

        DestroySwapchain ();
        DestroySurface ();
        DestroyDevice ();
        DestroyDebugFeatures ();
        DestroyInstance ();

        return false;
    }

    if ( DeployPresentFramebuffers () )
        return true;

    _physicalDeviceGroups.clear ();
    _physicalDeviceInfo.clear ();

    DestroyRenderPass ();
    DestroySwapchain ();
    DestroySurface ();
    DestroyDevice ();
    DestroyDebugFeatures ();
    DestroyInstance ();

    return false;
}

void Renderer::OnDestroy ()
{
    if ( !IsReady () )
        return;

    if ( !CheckVkResult ( vkDeviceWaitIdle ( _device ), "Renderer::OnDestroy", "Can't wait device idle" ) )
        return;

    _physicalDeviceGroups.clear ();
    _physicalDeviceInfo.clear ();

    DestroyPresentFramebuffers ();
    DestroySwapchain ();
    DestroyRenderPass ();
    DestroySurface ();
    DestroyDevice ();
    DestroyDebugFeatures ();
    DestroyInstance ();
}

bool Renderer::SelectTargetMemoryTypeIndex ( uint32_t &targetMemoryTypeIndex,
    const VkMemoryRequirements &memoryRequirements,
    VkMemoryPropertyFlags memoryProperties
) const
{
    for ( uint32_t i = 0U; i < _physicalDeviceMemoryProperties.memoryTypeCount; ++i )
    {
        if ( !( memoryRequirements.memoryTypeBits & ( 1U << i ) ) ) continue;

        const VkMemoryType& memoryType = _physicalDeviceMemoryProperties.memoryTypes[ i ];

        if ( ( memoryType.propertyFlags & memoryProperties ) != memoryProperties ) continue;

        targetMemoryTypeIndex = i;
        return true;
    }

    return false;
}

bool Renderer::DeployDebugFeatures ()
{
    vkCreateDebugReportCallbackEXT = reinterpret_cast<PFN_vkCreateDebugReportCallbackEXT> (
        vkGetInstanceProcAddr ( _instance, "vkCreateDebugReportCallbackEXT" )
    );

    assert ( vkCreateDebugReportCallbackEXT );

    vkDestroyDebugReportCallbackEXT = reinterpret_cast<PFN_vkDestroyDebugReportCallbackEXT> (
        vkGetInstanceProcAddr ( _instance, "vkDestroyDebugReportCallbackEXT" )
    );

    assert ( vkDestroyDebugReportCallbackEXT );

    _loggerMapper.insert (
        std::make_pair ( VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
            std::make_pair ( &LogInfo, "VK_DEBUG_REPORT_INFORMATION_BIT_EXT" )
        )
    );

    _loggerMapper.insert (
        std::make_pair ( VK_DEBUG_REPORT_WARNING_BIT_EXT,
            std::make_pair ( &LogWarning, "VK_DEBUG_REPORT_WARNING_BIT_EXT" )
        )
    );

    _loggerMapper.insert (
        std::make_pair ( VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
            std::make_pair ( &LogWarning, "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT" )
        )
    );

    _loggerMapper.insert (
        std::make_pair ( VK_DEBUG_REPORT_ERROR_BIT_EXT,
            std::make_pair ( &LogError, "VK_DEBUG_REPORT_ERROR_BIT_EXT" )
        )
    );

    _loggerMapper.insert (
        std::make_pair ( VK_DEBUG_REPORT_DEBUG_BIT_EXT,
            std::make_pair ( &LogDebug, "VK_DEBUG_REPORT_DEBUG_BIT_EXT" )
        )
    );

    return CheckVkResult (
        vkCreateDebugReportCallbackEXT ( _instance,
            &_debugReportCallbackCreateInfoEXT,
            nullptr,
            &_debugReportCallback
        ),

        "DeployDebugFeatures",
        "Can't Vulkan debug callback"
    );
}

void Renderer::DestroyDebugFeatures ()
{
    if ( !_debugReportCallback )
        return;

    vkDestroyDebugReportCallbackEXT ( _instance, _debugReportCallback, nullptr );
    _debugReportCallback = VK_NULL_HANDLE;
}

bool Renderer::DeployDevice ()
{
    constexpr const float priorities = 1.0F;

    VkDeviceQueueCreateInfo deviceQueueCreateInfo;
    deviceQueueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    deviceQueueCreateInfo.pNext = nullptr;
    deviceQueueCreateInfo.flags = 0U;
    deviceQueueCreateInfo.queueCount = 1U;
    deviceQueueCreateInfo.pQueuePriorities = &priorities;

    if ( !SelectTargetHardware ( _physicalDevice, _queueFamilyIndex ) )
        return false;

    deviceQueueCreateInfo.queueFamilyIndex = _queueFamilyIndex;

    const auto& caps = _physicalDeviceInfo[ _physicalDevice ];

    VkDeviceCreateInfo deviceCreateInfo;
    deviceCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    deviceCreateInfo.pNext = nullptr;
    deviceCreateInfo.flags = 0U;
    deviceCreateInfo.queueCreateInfoCount = 1U;
    deviceCreateInfo.pQueueCreateInfos = &deviceQueueCreateInfo;
    deviceCreateInfo.enabledLayerCount = 0U;
    deviceCreateInfo.ppEnabledLayerNames = nullptr;
    deviceCreateInfo.enabledExtensionCount = static_cast<uint32_t> ( caps._extensions.size () );
    deviceCreateInfo.ppEnabledExtensionNames = caps._extensions.data ();
    deviceCreateInfo.pEnabledFeatures = &caps._features;

    const bool result = CheckVkResult ( vkCreateDevice ( _physicalDevice, &deviceCreateInfo, nullptr, &_device ),
        "Renderer::DeployDevice",
        "Can't create device"
    );

    if ( !result )
        return false;

    AV_REGISTER_DEVICE ( "Renderer::_device" )
    vkGetDeviceQueue ( _device, _queueFamilyIndex, 0U, &_queue );
    return true;
}

void Renderer::DestroyDevice ()
{
    if ( !_device )
        return;

    vkDestroyDevice ( _device, nullptr );
    _device = VK_NULL_HANDLE;
    AV_UNREGISTER_DEVICE ( "Renderer::_device" )

    _queue = VK_NULL_HANDLE;
}

bool Renderer::DeployPresentFramebuffers ()
{
    _presentFramebuffers.clear ();
    _presentFramebuffers.reserve ( _swapchainImages.size () );

    VkImageView attachments[ 2U ];
    attachments[ 1U ] = _depthStencilImageView;

    constexpr const auto attachmentCount =
        static_cast<const uint32_t> ( sizeof ( attachments ) / sizeof ( attachments[ 0U ] ) );

    VkFramebufferCreateInfo framebufferInfo;
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebufferInfo.pNext = nullptr;
    framebufferInfo.renderPass = _renderPass;
    framebufferInfo.flags = 0U;
    framebufferInfo.attachmentCount = attachmentCount;
    framebufferInfo.pAttachments = attachments;
    framebufferInfo.width = _surfaceSize.width;
    framebufferInfo.height = _surfaceSize.height;
    framebufferInfo.layers = 1U;

    const size_t count = _swapchainImageViews.size ();

    for ( size_t i = 0U; i < count; ++i )
    {
        attachments[ 0U ] = _swapchainImageViews[ i ];
        VkFramebuffer framebuffer = VK_NULL_HANDLE;

        const bool result = CheckVkResult (
            vkCreateFramebuffer ( _device, &framebufferInfo, nullptr, &framebuffer ),
            "Renderer::DeployPresentFramebuffers",
            "Can't create framebuffer."
        );

        if ( !result )
        {
            DestroyPresentFramebuffers ();
            return false;
        }

        _presentFramebuffers.push_back ( framebuffer );

        AV_REGISTER_FRAMEBUFFER (
            "Renderer::_presentFramebuffers[ " + std::to_string ( static_cast<int> ( i ) ) + "U ]"
        )
    }

    return true;
}

void Renderer::DestroyPresentFramebuffers ()
{
    const size_t count = _presentFramebuffers.size ();

    for ( size_t i = 0U; i < count; ++i )
    {
        vkDestroyFramebuffer ( _device, _presentFramebuffers[ i ], nullptr );

        AV_UNREGISTER_FRAMEBUFFER (
            "Renderer::_presentFramebuffers[ " + std::to_string ( static_cast<int> ( i ) ) + "U ]"
        )
    }
}

bool Renderer::DeployInstance ()
{
    _debugReportCallbackCreateInfoEXT.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    _debugReportCallbackCreateInfoEXT.pNext = nullptr;
    _debugReportCallbackCreateInfoEXT.pUserData = this;
    _debugReportCallbackCreateInfoEXT.pfnCallback = &Renderer::OnVulkanDebugReport;

    _debugReportCallbackCreateInfoEXT.flags =
        VK_DEBUG_REPORT_INFORMATION_BIT_EXT |
        VK_DEBUG_REPORT_WARNING_BIT_EXT |
        VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
        VK_DEBUG_REPORT_ERROR_BIT_EXT |
        VK_DEBUG_REPORT_DEBUG_BIT_EXT;

    VkApplicationInfo applicationInfo;
    applicationInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    applicationInfo.pNext = nullptr;
    applicationInfo.apiVersion = TARGET_VULKAN_VERSION;
    applicationInfo.pApplicationName = APPLICATION_NAME;
    applicationInfo.applicationVersion = 1U;
    applicationInfo.pEngineName = ENGINE_NAME;
    applicationInfo.engineVersion = 1U;

    constexpr static const char* extensions[] =
    {
        VK_EXT_DEBUG_REPORT_EXTENSION_NAME,
        VK_KHR_SURFACE_EXTENSION_NAME,
        "VK_KHR_android_surface"
    };

    constexpr const uint32_t extensionCount =
        static_cast<const uint32_t> ( sizeof ( extensions ) / sizeof ( extensions[ 0U ] ) );

    VkInstanceCreateInfo instanceCreateInfo;
    instanceCreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    instanceCreateInfo.pNext = &_debugReportCallbackCreateInfoEXT;
    instanceCreateInfo.flags = 0U;
    instanceCreateInfo.pApplicationInfo = &applicationInfo;
    instanceCreateInfo.enabledLayerCount = 0U;
    instanceCreateInfo.ppEnabledLayerNames = nullptr;
    instanceCreateInfo.enabledExtensionCount = extensionCount;
    instanceCreateInfo.ppEnabledExtensionNames = extensions;

    return CheckVkResult ( vkCreateInstance ( &instanceCreateInfo, nullptr, &_instance ),
        "Renderer::DeployInstance",
        "Can't create Vulkan instance"
    );
}

void Renderer::DestroyInstance ()
{
    if ( !_instance )
        return;

    vkDestroyInstance ( _instance, nullptr );
    _instance = VK_NULL_HANDLE;
}

bool Renderer::DeployRenderPass ()
{
    VkAttachmentDescription attachmentDescriptions[ 2U ];
    VkAttachmentDescription& attachment0 = attachmentDescriptions[ 0U ];
    attachment0.flags = 0U;
    attachment0.format = _surfaceFormat;
    attachment0.samples = VK_SAMPLE_COUNT_1_BIT;
    attachment0.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    attachment0.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    attachment0.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    attachment0.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attachment0.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    attachment0.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentDescription& attachment1 = attachmentDescriptions[ 1U ];
    attachment1.flags = 0U;
    attachment1.format = _depthStencilImageFormat;
    attachment1.samples = VK_SAMPLE_COUNT_1_BIT;
    attachment1.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    attachment1.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attachment1.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    attachment1.stencilStoreOp = VK_ATTACHMENT_STORE_OP_STORE;
    attachment1.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    attachment1.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    constexpr const auto attachmentCount =
        static_cast<const uint32_t> ( sizeof ( attachmentDescriptions ) / sizeof ( attachmentDescriptions[ 0U ] ) );

    VkAttachmentReference colorAttachmentReference;
    colorAttachmentReference.attachment = 0U;
    colorAttachmentReference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    VkAttachmentReference depthStencilAttachmentReference;
    depthStencilAttachmentReference.attachment = 1U;
    depthStencilAttachmentReference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkSubpassDescription subpassDescription;
    subpassDescription.flags = 0U;
    subpassDescription.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpassDescription.inputAttachmentCount = 0U;
    subpassDescription.pInputAttachments = nullptr;
    subpassDescription.colorAttachmentCount = 1U;
    subpassDescription.pColorAttachments = &colorAttachmentReference;
    subpassDescription.pResolveAttachments = nullptr;
    subpassDescription.pDepthStencilAttachment = &depthStencilAttachmentReference;
    subpassDescription.preserveAttachmentCount = 0U;
    subpassDescription.pPreserveAttachments = nullptr;

    VkRenderPassCreateInfo renderPassCreateInfo;
    renderPassCreateInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassCreateInfo.pNext = nullptr;
    renderPassCreateInfo.flags = 0U;
    renderPassCreateInfo.attachmentCount = attachmentCount;
    renderPassCreateInfo.pAttachments = attachmentDescriptions;
    renderPassCreateInfo.subpassCount = 1U;
    renderPassCreateInfo.pSubpasses = &subpassDescription;
    renderPassCreateInfo.dependencyCount = 0U;
    renderPassCreateInfo.pDependencies = nullptr;

    const bool result = CheckVkResult ( vkCreateRenderPass ( _device, &renderPassCreateInfo, nullptr, &_renderPass ),
        "Renderer::DeployRenderPass",
        "Can't create render pass"
    );

    if ( !result )
        return false;

    AV_REGISTER_RENDER_PASS ( "Renderer::_renderPass" )
    return true;
}

void Renderer::DestroyRenderPass ()
{
    vkDestroyRenderPass ( _device, _renderPass, nullptr );
    _renderPass = VK_NULL_HANDLE;
    AV_UNREGISTER_RENDER_PASS ( "Renderer::_renderPass" )
}

bool Renderer::DeploySurface ( ANativeWindow &nativeWindow )
{
    VkAndroidSurfaceCreateInfoKHR androidSurfaceCreateInfoKHR;
    androidSurfaceCreateInfoKHR.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
    androidSurfaceCreateInfoKHR.pNext = nullptr;
    androidSurfaceCreateInfoKHR.flags = 0U;
    androidSurfaceCreateInfoKHR.window = &nativeWindow;

    bool result = CheckVkResult (
        vkCreateAndroidSurfaceKHR ( _instance, &androidSurfaceCreateInfoKHR, nullptr, &_surface ),
        "Renderer::DeploySurface",
        "Can't create Vulkan surface"
    );

    if ( !result )
        return false;

    AV_REGISTER_SURFACE ( "Renderer::_surface" )
    VkSurfaceCapabilitiesKHR surfaceCapabilitiesKHR;

    result = CheckVkResult (
        vkGetPhysicalDeviceSurfaceCapabilitiesKHR ( _physicalDevice, _surface, &surfaceCapabilitiesKHR ),
        "Renderer::DeploySurface",
        "Can't get Vulkan surface capabilities"
    );

    if ( !result )
    {
        DestroySurface ();
        return false;
    }

    PrintVkSurfaceCapabilities ( surfaceCapabilitiesKHR );
    _surfaceSize = surfaceCapabilitiesKHR.currentExtent;

    VkBool32 isSupported = VK_FALSE;

    result = CheckVkResult (
        vkGetPhysicalDeviceSurfaceSupportKHR ( _physicalDevice, _queueFamilyIndex, _surface, &isSupported ),
        "Renderer::DeploySurface",
        "Can't check Vulkan surface support by physical device"
    );

    if ( !result )
    {
        DestroySurface ();
        return false;
    }

    if ( !isSupported )
    {
        DestroySurface ();

        LogError ( "Renderer::DeploySurface - Physical device does not support by Vulkan surface. Error: %s." );
        assert ( !"Renderer::DeploySurface - Physical device does not support by Vulkan surface." );

        return false;
    }

    uint32_t formatCount = 0U;
    vkGetPhysicalDeviceSurfaceFormatsKHR ( _physicalDevice, _surface, &formatCount, nullptr );

    if ( !formatCount )
    {
        DestroySurface ();

        LogError ( "Renderer::DeploySurface - There is not any Vulkan surface formats." );
        assert ( !"Renderer::DeploySurface - There is not any Vulkan surface formats." );

        return false;
    }

    LogInfo ( "Renderer::DeploySurface - Vulkan surface formats detected: %u.", formatCount );

    _surfaceFormats.resize ( static_cast<size_t> ( formatCount ) );
    VkSurfaceFormatKHR* formatList = _surfaceFormats.data ();

    result = CheckVkResult (
        vkGetPhysicalDeviceSurfaceFormatsKHR ( _physicalDevice, _surface, &formatCount, formatList ),
        "Renderer::DeploySurface",
        "Can't get Vulkan surface formats"
    );

    if ( !result )
    {
        DestroySurface ();
        return false;
    }

    for ( uint32_t i = 0U; i < formatCount; ++i )
        PrintVkSurfaceFormatKHRProp ( i, formatList[ i ] );

    return true;
}

void Renderer::DestroySurface ()
{
    vkDestroySurfaceKHR ( _instance, _surface, nullptr );
    _surface = VK_NULL_HANDLE;
    AV_UNREGISTER_SURFACE ( "Renderer::_surface" )
}

bool Renderer::DeploySwapchain ( bool vSync )
{
    VkSwapchainCreateInfoKHR swapchainCreateInfoKHR;
    swapchainCreateInfoKHR.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    swapchainCreateInfoKHR.pNext = nullptr;
    swapchainCreateInfoKHR.flags = 0U;
    swapchainCreateInfoKHR.surface = _surface;
    swapchainCreateInfoKHR.minImageCount = 2U;
    swapchainCreateInfoKHR.imageArrayLayers = 1U;
    swapchainCreateInfoKHR.imageExtent = _surfaceSize;
    swapchainCreateInfoKHR.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    swapchainCreateInfoKHR.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    swapchainCreateInfoKHR.queueFamilyIndexCount = VK_QUEUE_FAMILY_IGNORED;
    swapchainCreateInfoKHR.pQueueFamilyIndices = nullptr;
    swapchainCreateInfoKHR.preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
    swapchainCreateInfoKHR.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    swapchainCreateInfoKHR.clipped = VK_TRUE;
    swapchainCreateInfoKHR.oldSwapchain = VK_NULL_HANDLE;

    if ( !SelectTargetPresentMode ( swapchainCreateInfoKHR.presentMode, vSync ) )
        return false;

    bool result = SelectTargetSurfaceFormat ( _surfaceFormat,
        swapchainCreateInfoKHR.imageColorSpace,
        _depthStencilImageFormat
    );

    if ( !result )
    {
        LogError ( "Renderer::DeploySwapchain - Can't select image format and color space." );
        assert ( !"Renderer::DeploySwapchain - Can't select image format and color space." );
        return false;
    }

    swapchainCreateInfoKHR.imageFormat = _surfaceFormat;

    result = CheckVkResult ( vkCreateSwapchainKHR ( _device, &swapchainCreateInfoKHR, nullptr, &_swapchain ),
        "Renderer::DeploySwapchain",
        "Can't create swapchain"
    );

    if ( !result )
        return false;

    AV_REGISTER_SWAPCHAIN ( "Renderer::_swapchain" )

    uint32_t imageCount = 0U;
    vkGetSwapchainImagesKHR ( _device, _swapchain, &imageCount, nullptr );

    if ( !imageCount )
    {
        DestroySwapchain ();

        LogError ( "Renderer::DeploySwapchain - There is no any swapchain images." );
        assert ( !"Renderer::DeploySwapchain - There is no any swapchain images." );

        return false;
    }

    LogInfo ( "Renderer::DeploySwapchain - Swapchain images detected: %u.", imageCount );

    _swapchainImages.resize ( static_cast<size_t> ( imageCount ) );

    result = CheckVkResult ( vkGetSwapchainImagesKHR ( _device, _swapchain, &imageCount, _swapchainImages.data () ),
        "Renderer::DeploySwapchain",
        "Can't create swapchain"
    );

    if ( !result )
        return false;

    _swapchainImageViews.clear ();
    _swapchainImageViews.reserve ( static_cast<size_t> ( imageCount ) );

    VkImageViewCreateInfo imageViewCreateInfo;
    imageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    imageViewCreateInfo.pNext = nullptr;
    imageViewCreateInfo.flags = 0U;
    imageViewCreateInfo.format = swapchainCreateInfoKHR.imageFormat;
    imageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    imageViewCreateInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    imageViewCreateInfo.subresourceRange.layerCount = 1U;
    imageViewCreateInfo.subresourceRange.baseArrayLayer = 0U;
    imageViewCreateInfo.subresourceRange.levelCount = 1U;
    imageViewCreateInfo.subresourceRange.baseMipLevel = 0U;

    for ( uint32_t i = 0U; i < imageCount; ++i )
    {
        imageViewCreateInfo.image = _swapchainImages[ i ];
        VkImageView imageView = VK_NULL_HANDLE;

        result = CheckVkResult ( vkCreateImageView ( _device, &imageViewCreateInfo, nullptr, &imageView ),
            "Renderer::DeploySwapchain",
            "Can't create swapchain image view"
        );

        if ( result )
        {
            _swapchainImageViews.push_back ( imageView );

            AV_REGISTER_IMAGE_VIEW (
                "Renderer::_swapchainImageViews[ " + std::to_string ( static_cast<int> ( i ) ) + "U ]"
            );

            continue;
        }

        DestroySwapchain ();
        return false;
    }

    VkImageCreateInfo imageCreateInfo;
    imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageCreateInfo.pNext = nullptr;
    imageCreateInfo.flags = 0U;
    imageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
    imageCreateInfo.format = _depthStencilImageFormat;
    imageCreateInfo.extent.width = _surfaceSize.width;
    imageCreateInfo.extent.height = _surfaceSize.height;
    imageCreateInfo.extent.depth = 1U;
    imageCreateInfo.mipLevels = 1U;
    imageCreateInfo.arrayLayers = 1U;
    imageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageCreateInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
    imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    imageCreateInfo.queueFamilyIndexCount = VK_QUEUE_FAMILY_IGNORED;
    imageCreateInfo.pQueueFamilyIndices = nullptr;
    imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

    result = CheckVkResult ( vkCreateImage ( _device, &imageCreateInfo, nullptr, &_depthStencilImage ),
        "Renderer::DeploySwapchain",
        "Can't create depth stencil image"
    );

    if ( !result )
    {
        DestroySwapchain ();
        return false;
    }

    AV_REGISTER_IMAGE ( "Renderer::_depthStencilImage" )

    VkMemoryRequirements memoryRequirements;
    vkGetImageMemoryRequirements ( _device, _depthStencilImage, &memoryRequirements );

    VkMemoryAllocateInfo memoryAllocateInfo;
    memoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    memoryAllocateInfo.pNext = nullptr;
    memoryAllocateInfo.allocationSize = memoryRequirements.size;
    memoryAllocateInfo.memoryTypeIndex = 0U;

    result = SelectTargetMemoryTypeIndex ( memoryAllocateInfo.memoryTypeIndex,
        memoryRequirements,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
    );

    if ( !result )
    {
        LogError ( "Renderer::DeploySwapchain - Can't resolve memory type index for depth|stencil image.");
        assert ( !"Renderer::DeploySwapchain - Can't resolve memory type index for depth|stencil image." );
        DestroySwapchain ();
        return false;
    }

    result = CheckVkResult ( vkAllocateMemory ( _device, &memoryAllocateInfo, nullptr, &_depthStencilImageMemory ),
        "Renderer::DeploySwapchain",
        "Can't allocate depth stencil image memory"
    );

    if ( !result )
    {
        DestroySwapchain ();
        return false;
    }

    AV_REGISTER_DEVICE_MEMORY ( "Renderer::_depthStencilImageMemory" )

    result = CheckVkResult ( vkBindImageMemory ( _device, _depthStencilImage, _depthStencilImageMemory, 0U ),
        "Renderer::DeploySwapchain",
        "Can't bind depth stencil image with memory"
    );

    if ( !result )
    {
        DestroySwapchain ();
        return false;
    }

    imageViewCreateInfo.image = _depthStencilImage;
    imageViewCreateInfo.pNext = nullptr;
    imageViewCreateInfo.flags = 0U;
    imageViewCreateInfo.image = _depthStencilImage;
    imageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    imageViewCreateInfo.format = _depthStencilImageFormat;
    imageViewCreateInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
    imageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT;
    imageViewCreateInfo.subresourceRange.layerCount = 1U;
    imageViewCreateInfo.subresourceRange.baseArrayLayer = 0U;
    imageViewCreateInfo.subresourceRange.levelCount = 1U;
    imageViewCreateInfo.subresourceRange.baseMipLevel = 0U;

    result = CheckVkResult ( vkCreateImageView ( _device, &imageViewCreateInfo, nullptr, &_depthStencilImageView ),
        "Renderer::DeploySwapchain",
        "Can't bind depth stencil image with memory"
    );

    if ( result )
    {
        AV_REGISTER_IMAGE_VIEW ( "Renderer::_depthStencilImageView" )
        return true;
    }

    DestroySwapchain ();
    return false;
}

void Renderer::DestroySwapchain ()
{
    if ( _depthStencilImageView )
    {
        vkDestroyImageView ( _device, _depthStencilImageView, nullptr );
        _depthStencilImageView = VK_NULL_HANDLE;
        AV_UNREGISTER_IMAGE_VIEW ( "Renderer::_depthStencilImageView" )
    }

    if ( _depthStencilImageMemory )
    {
        vkFreeMemory ( _device, _depthStencilImageMemory, nullptr );
        _depthStencilImageMemory = VK_NULL_HANDLE;
        AV_UNREGISTER_DEVICE_MEMORY ( "Renderer::_depthStencilImageMemory" )
    }

    if ( _depthStencilImage )
    {
        vkDestroyImage ( _device, _depthStencilImage, nullptr );
        _depthStencilImage = VK_NULL_HANDLE;
        AV_UNREGISTER_IMAGE ( "Renderer::_depthStencilImage" )
    }

    const size_t count = _swapchainImageViews.size ();

    for ( size_t i = 0U; i < count; ++i )
    {
        vkDestroyImageView ( _device, _swapchainImageViews[ i ], nullptr );

        AV_UNREGISTER_IMAGE_VIEW (
            "Renderer::_swapchainImageViews[ " + std::to_string ( static_cast<int> ( i ) ) + "U ]"
        );
    }

    vkDestroySwapchainKHR ( _device, _swapchain, nullptr );
    _swapchain = VK_NULL_HANDLE;
    AV_UNREGISTER_SWAPCHAIN ( "Renderer::_swapchain" )
}

bool Renderer::PrintCoreExtensions () const
{
    uint32_t extensionCount = 0U;
    vkEnumerateInstanceExtensionProperties ( nullptr, &extensionCount, nullptr );

    if ( !extensionCount )
    {
        LogError ( "Renderer::PrintCoreExtensions - There is no any core extensions!" );
        assert ( !"Renderer::PrintCoreExtensions - There is no any core extensions!" );

        return false;
    }

    LogInfo ( "Renderer::PrintCoreExtensions - Instance core extensions detected: %u.", extensionCount );

    std::vector<VkExtensionProperties> extensions ( static_cast<size_t> ( extensionCount ) );
    VkExtensionProperties* extensionList = extensions.data ();

    const bool result = CheckVkResult (
        vkEnumerateInstanceExtensionProperties ( nullptr, &extensionCount, extensionList ),
        "Renderer::PrintCoreExtensions",
        "Can't get instance core extensions"
    );

    if ( !result )
        return false;

    for ( uint32_t i = 0U; i < extensionCount; ++i )
        PrintVkExtensionProp ( i, "Instance core", extensionList[ i ] );

    return true;
}

void Renderer::PrintFloatProp ( const char* indent, const char* name, float value ) const
{
    LogInfo ( "%s%s: %g", indent, name, value );
}

void Renderer::PrintFloatVec2Prop ( const char* indent, const char* name, const float value[] ) const
{
    LogInfo ( "%s%s: %g, %g", indent, name, value[ 0U ], value[ 1U ] );
}

void Renderer::PrintINT32Prop ( const char* indent, const char* name, int32_t value ) const
{
    LogInfo ( "%s%s: %i", indent, name, value );
}

bool Renderer::PrintInstanceLayerInfo () const
{
    uint32_t layerCount = 0U;
    vkEnumerateInstanceLayerProperties ( &layerCount, nullptr );

    if ( !layerCount )
    {
        LogInfo ( "Renderer::PrintInstanceLayerInfo - Instance does not contain any layers." );
        return PrintCoreExtensions ();
    }

    LogInfo ( ">>> Instance layers detected: %u.", layerCount );

    std::vector<VkLayerProperties> layers ( static_cast<size_t> ( layerCount ) );
    VkLayerProperties* layerList = layers.data ();

    const bool result = CheckVkResult ( vkEnumerateInstanceLayerProperties ( &layerCount, layerList ),
        "Renderer::PrintCoreExtensions",
        "Can't get instance core extensions"
    );

    if ( !result )
        return false;

    for ( uint32_t i = 0U; i < layerCount; ++i )
        PrintVkLayerProperties ( i, layerList[ i ] );

    return PrintCoreExtensions ();
}

void Renderer::PrintPhysicalDeviceCommonProps ( const VkPhysicalDeviceProperties &props ) const
{
    LogInfo ( ">>> Common properties:" );

    PrintVkVersion ( INDENT_1, "apiVersion", props.apiVersion );
    PrintUINT32Prop ( INDENT_1, "driverVersion", props.driverVersion );
    PrintUINT32Prop ( INDENT_1, "vendorID", props.vendorID );
    PrintUINT32Prop ( INDENT_1, "deviceID", props.deviceID );
    PrintUTF8Prop ( INDENT_1, "deviceType", ResolvePhysicalDeviceType ( props.deviceType ) );
    PrintUTF8Prop ( INDENT_1, "deviceName", props.deviceName );

    LogInfo ( "%spipelineCacheUUID: {%x%x%x%x-%x%x-%x%x-%x%x-%x%x%x%x%x%x}",
        INDENT_1,
        props.pipelineCacheUUID[ 0U ],
        props.pipelineCacheUUID[ 1U ],
        props.pipelineCacheUUID[ 2U ],
        props.pipelineCacheUUID[ 3U ],
        props.pipelineCacheUUID[ 4U ],
        props.pipelineCacheUUID[ 5U ],
        props.pipelineCacheUUID[ 6U ],
        props.pipelineCacheUUID[ 7U ],
        props.pipelineCacheUUID[ 8U ],
        props.pipelineCacheUUID[ 9U ],
        props.pipelineCacheUUID[ 10U ],
        props.pipelineCacheUUID[ 11U ],
        props.pipelineCacheUUID[ 12U ],
        props.pipelineCacheUUID[ 13U ],
        props.pipelineCacheUUID[ 14U ],
        props.pipelineCacheUUID[ 15U ]
    );
}

bool Renderer::PrintPhysicalDeviceExtensionInfo ( VkPhysicalDevice physicalDevice )
{
    uint32_t extensionCount = 0U;
    vkEnumerateDeviceExtensionProperties ( physicalDevice, nullptr, &extensionCount, nullptr );

    if ( !extensionCount )
    {
        LogError ( "Renderer::PrintPhysicalDeviceExtensionInfo - There is no any physical device extensions." );
        assert ( !"Renderer::PrintPhysicalDeviceExtensionInfo - There is no any physical device extensions." );

        return false;
    }

    LogInfo ( ">>> Physical device extensions detected: %u.", extensionCount);

    std::vector<VkExtensionProperties> extensions ( static_cast<size_t> ( extensionCount ) );
    VkExtensionProperties* extensionList = extensions.data ();

    const bool result = CheckVkResult (
        vkEnumerateDeviceExtensionProperties ( physicalDevice,
            nullptr,
            &extensionCount,
            extensionList
        ),

        "Renderer::PrintPhysicalDeviceExtensionInfo",
        "Can't get physical device extensions"
    );

    if ( !result )
        return false;

    VulkanPhysicalDeviceInfo& capabilities = _physicalDeviceInfo[ physicalDevice ];
    std::vector<const char*>& targetExtensions = capabilities._extensions;
    std::vector<char>& targetExtensionStorage = capabilities._extensionStorage;

    targetExtensions.reserve ( static_cast<size_t> ( extensionCount ) );
    size_t offset = 0U;

    for ( uint32_t i = 0U; i < extensionCount; ++i )
    {
        const VkExtensionProperties& prop = extensionList[ i ];
        PrintVkExtensionProp ( i, "Physical device", prop );

        const size_t size = strlen ( prop.extensionName ) + 1U;
        const size_t neededSpace = offset + size;

        while ( targetExtensionStorage.size () < neededSpace )
            targetExtensionStorage.resize ( targetExtensionStorage.size () * 2U );

        memcpy ( targetExtensionStorage.data () + offset, prop.extensionName, size );
        targetExtensions.push_back ( reinterpret_cast<const char*> ( offset ) );

        offset = neededSpace;
    }

    // Adjusting extension pointers.
    offset = reinterpret_cast<size_t> ( targetExtensionStorage.data () );

    for ( auto& pointer : targetExtensions )
        pointer += offset;

    return true;
}

bool Renderer::PrintPhysicalDeviceFeatureInfo ( VkPhysicalDevice physicalDevice )
{
    auto& features = _physicalDeviceInfo[ physicalDevice ];
    vkGetPhysicalDeviceFeatures ( physicalDevice, &features._features );

    bool featureDetected = false;

    for ( auto const& probe : g_vkFeatureMap )
    {
        const auto enable = *reinterpret_cast<const VkBool32*> (
            reinterpret_cast<const uint8_t*> ( &features._features ) + probe.first
        );

        if ( !enable ) continue;

        if ( !featureDetected )
        {
            LogInfo ( ">>> Features:" );
            featureDetected = true;
        }

        LogInfo ( "%s%s", INDENT_1, probe.second );
    }

    if ( featureDetected )
        return true;

    LogError ( "Renderer::PrintPhysicalDeviceFeatureInfo - Feature list is empty!" );
    assert ( !"Renderer::PrintPhysicalDeviceFeatureInfo - Feature list is empty!" );

    return false;
}

void Renderer::PrintPhysicalDeviceGroupInfo ( uint32_t groupIndex,
    const VkPhysicalDeviceGroupProperties &props
) const
{
    LogInfo ( "Renderer::PrintPhysicalDeviceGroupInfo - Vulkan physical device group #%u", groupIndex );

    PrintUINT32Prop ( INDENT_1, "physicalDeviceCount", props.physicalDeviceCount );

    for ( uint32_t i = 0U; i < props.physicalDeviceCount; ++i )
        PrintVkHandler ( INDENT_2, "Device handler", props.physicalDevices[ i ] );

    PrintVkBool32Prop ( INDENT_1, "subsetAllocation", props.subsetAllocation );
}

bool Renderer::PrintPhysicalDeviceLayerInfo ( const VkPhysicalDevice physicalDevice ) const
{
    uint32_t layerCount = 0U;
    vkEnumerateDeviceLayerProperties ( physicalDevice, &layerCount, nullptr );

    LogInfo ( ">>> Physical device layers detected: %u.", layerCount );

    if ( !layerCount )
        return true;

    std::vector<VkLayerProperties> layers ( static_cast<size_t> ( layerCount ) );
    VkLayerProperties* layerList = layers.data ();

    const bool result = CheckVkResult ( vkEnumerateDeviceLayerProperties ( physicalDevice, &layerCount, layerList ),
        "Renderer::PrintPhysicalDeviceLayerInfo",
        "Can't get physical device layers"
    );

    if ( !result )
        return false;

    for ( uint32_t i = 0U; i < layerCount; ++i )
        PrintVkLayerProperties ( i, layerList[ i ] );

    return true;
}

void Renderer::PrintPhysicalDeviceLimits ( const VkPhysicalDeviceLimits &limits ) const
{
    LogInfo ( ">>> Limits:" );

    PrintUINT32Prop ( INDENT_1, "maxImageDimension1D", limits.maxImageDimension1D );
    PrintUINT32Prop ( INDENT_1, "maxImageDimension2D", limits.maxImageDimension2D );
    PrintUINT32Prop ( INDENT_1, "maxImageDimension3D", limits.maxImageDimension3D );
    PrintUINT32Prop ( INDENT_1, "maxImageDimensionCube", limits.maxImageDimensionCube );
    PrintUINT32Prop ( INDENT_1, "maxImageArrayLayers", limits.maxImageArrayLayers );
    PrintUINT32Prop ( INDENT_1, "maxTexelBufferElements", limits.maxTexelBufferElements );
    PrintUINT32Prop ( INDENT_1, "maxUniformBufferRange", limits.maxUniformBufferRange );
    PrintUINT32Prop ( INDENT_1, "maxStorageBufferRange", limits.maxStorageBufferRange );
    PrintUINT32Prop ( INDENT_1, "maxPushConstantsSize", limits.maxPushConstantsSize );
    PrintUINT32Prop ( INDENT_1, "maxMemoryAllocationCount", limits.maxMemoryAllocationCount );
    PrintUINT32Prop ( INDENT_1, "maxSamplerAllocationCount", limits.maxSamplerAllocationCount );
    PrintSizeProp ( INDENT_1, "bufferImageGranularity", static_cast<size_t> ( limits.bufferImageGranularity ) );
    PrintSizeProp ( INDENT_1, "sparseAddressSpaceSize", static_cast<size_t> ( limits.sparseAddressSpaceSize ) );
    PrintUINT32Prop ( INDENT_1, "maxBoundDescriptorSets", limits.maxBoundDescriptorSets );
    PrintUINT32Prop ( INDENT_1, "maxPerStageDescriptorSamplers", limits.maxPerStageDescriptorSamplers );
    PrintUINT32Prop ( INDENT_1, "maxPerStageDescriptorUniformBuffers", limits.maxPerStageDescriptorUniformBuffers );
    PrintUINT32Prop ( INDENT_1, "maxPerStageDescriptorStorageBuffers", limits.maxPerStageDescriptorStorageBuffers );
    PrintUINT32Prop ( INDENT_1, "maxPerStageDescriptorSampledImages", limits.maxPerStageDescriptorSampledImages );
    PrintUINT32Prop ( INDENT_1, "maxPerStageDescriptorStorageImages", limits.maxPerStageDescriptorStorageImages );
    PrintUINT32Prop ( INDENT_1, "maxPerStageDescriptorInputAttachments", limits.maxPerStageDescriptorInputAttachments );
    PrintUINT32Prop ( INDENT_1, "maxPerStageResources", limits.maxPerStageResources );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetSamplers", limits.maxDescriptorSetSamplers );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetUniformBuffers", limits.maxDescriptorSetUniformBuffers );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetUniformBuffersDynamic", limits.maxDescriptorSetUniformBuffersDynamic );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetStorageBuffers", limits.maxDescriptorSetStorageBuffers );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetStorageBuffersDynamic", limits.maxDescriptorSetStorageBuffersDynamic );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetSampledImages", limits.maxDescriptorSetSampledImages );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetStorageImages", limits.maxDescriptorSetStorageImages );
    PrintUINT32Prop ( INDENT_1, "maxDescriptorSetInputAttachments", limits.maxDescriptorSetInputAttachments );
    PrintUINT32Prop ( INDENT_1, "maxVertexInputAttributes", limits.maxVertexInputAttributes );
    PrintUINT32Prop ( INDENT_1, "maxVertexInputBindings", limits.maxVertexInputBindings );
    PrintUINT32Prop ( INDENT_1, "maxVertexInputAttributeOffset", limits.maxVertexInputAttributeOffset );
    PrintUINT32Prop ( INDENT_1, "maxVertexInputBindingStride", limits.maxVertexInputBindingStride );
    PrintUINT32Prop ( INDENT_1, "maxVertexOutputComponents", limits.maxVertexOutputComponents );
    PrintUINT32Prop ( INDENT_1, "maxTessellationGenerationLevel", limits.maxTessellationGenerationLevel );
    PrintUINT32Prop ( INDENT_1, "maxTessellationPatchSize", limits.maxTessellationPatchSize );

    PrintUINT32Prop ( INDENT_1,
        "maxTessellationControlPerVertexInputComponents",
        limits.maxTessellationControlPerVertexInputComponents
    );

    PrintUINT32Prop ( INDENT_1,
        "maxTessellationControlPerVertexOutputComponents",
        limits.maxTessellationControlPerVertexOutputComponents
    );

    PrintUINT32Prop ( INDENT_1,
        "maxTessellationControlPerPatchOutputComponents",
        limits.maxTessellationControlPerPatchOutputComponents
    );

    PrintUINT32Prop ( INDENT_1,
        "maxTessellationControlTotalOutputComponents",
        limits.maxTessellationControlTotalOutputComponents
    );

    PrintUINT32Prop ( INDENT_1,
        "maxTessellationEvaluationInputComponents",
        limits.maxTessellationEvaluationInputComponents
    );

    PrintUINT32Prop ( INDENT_1,
        "maxTessellationEvaluationOutputComponents",
        limits.maxTessellationEvaluationOutputComponents
    );

    PrintUINT32Prop ( INDENT_1, "maxGeometryShaderInvocations", limits.maxGeometryShaderInvocations );
    PrintUINT32Prop ( INDENT_1, "maxGeometryInputComponents", limits.maxGeometryInputComponents );
    PrintUINT32Prop ( INDENT_1, "maxGeometryOutputComponents", limits.maxGeometryOutputComponents );
    PrintUINT32Prop ( INDENT_1, "maxGeometryOutputVertices", limits.maxGeometryOutputVertices );
    PrintUINT32Prop ( INDENT_1, "maxGeometryTotalOutputComponents", limits.maxGeometryTotalOutputComponents );
    PrintUINT32Prop ( INDENT_1, "maxFragmentInputComponents", limits.maxFragmentInputComponents );
    PrintUINT32Prop ( INDENT_1, "maxFragmentOutputAttachments", limits.maxFragmentOutputAttachments );
    PrintUINT32Prop ( INDENT_1, "maxFragmentDualSrcAttachments", limits.maxFragmentDualSrcAttachments );
    PrintUINT32Prop ( INDENT_1, "maxFragmentCombinedOutputResources", limits.maxFragmentCombinedOutputResources );
    PrintUINT32Prop ( INDENT_1, "maxComputeSharedMemorySize", limits.maxComputeSharedMemorySize );

    PrintUINT32Vec3Prop ( INDENT_1, "maxComputeWorkGroupCount", limits.maxComputeWorkGroupCount );
    PrintUINT32Prop ( INDENT_1, "maxComputeWorkGroupInvocations", limits.maxComputeWorkGroupInvocations );
    PrintUINT32Vec3Prop ( INDENT_1, "maxComputeWorkGroupSize", limits.maxComputeWorkGroupSize );
    PrintUINT32Prop ( INDENT_1, "subPixelPrecisionBits", limits.subPixelPrecisionBits );
    PrintUINT32Prop ( INDENT_1, "subTexelPrecisionBits", limits.subTexelPrecisionBits );
    PrintUINT32Prop ( INDENT_1, "mipmapPrecisionBits", limits.mipmapPrecisionBits );
    PrintUINT32Prop ( INDENT_1, "maxDrawIndexedIndexValue", limits.maxDrawIndexedIndexValue );
    PrintUINT32Prop ( INDENT_1, "maxDrawIndirectCount", limits.maxDrawIndirectCount );
    PrintFloatProp ( INDENT_1, "maxSamplerLodBias", limits.maxSamplerLodBias );
    PrintFloatProp ( INDENT_1, "maxSamplerAnisotropy", limits.maxSamplerAnisotropy );
    PrintUINT32Prop ( INDENT_1, "maxViewports", limits.maxViewports );
    PrintUINT32Vec2Prop ( INDENT_1, "maxViewportDimensions", limits.maxViewportDimensions );
    PrintFloatVec2Prop ( INDENT_1, "viewportBoundsRange", limits.viewportBoundsRange );
    PrintUINT32Prop ( INDENT_1, "viewportSubPixelBits", limits.viewportSubPixelBits );
    PrintSizeProp ( INDENT_1, "minMemoryMapAlignment", limits.minMemoryMapAlignment );

    PrintSizeProp ( INDENT_1,
        "minTexelBufferOffsetAlignment",
        static_cast<size_t> ( limits.minTexelBufferOffsetAlignment )
    );

    PrintSizeProp ( INDENT_1,
        "minUniformBufferOffsetAlignment",
        static_cast<size_t> ( limits.minUniformBufferOffsetAlignment )
    );

    PrintSizeProp ( INDENT_1,
        "minStorageBufferOffsetAlignment",
        static_cast<size_t> ( limits.minStorageBufferOffsetAlignment )
    );

    PrintINT32Prop ( INDENT_1, "minTexelOffset", limits.minTexelOffset );
    PrintUINT32Prop ( INDENT_1, "maxTexelOffset", limits.maxTexelOffset );
    PrintINT32Prop ( INDENT_1, "minTexelGatherOffset", limits.minTexelGatherOffset );
    PrintUINT32Prop ( INDENT_1, "maxTexelGatherOffset", limits.maxTexelGatherOffset );
    PrintFloatProp ( INDENT_1, "minInterpolationOffset", limits.minInterpolationOffset );
    PrintFloatProp ( INDENT_1, "maxInterpolationOffset", limits.maxInterpolationOffset );
    PrintUINT32Prop ( INDENT_1, "subPixelInterpolationOffsetBits", limits.subPixelInterpolationOffsetBits );
    PrintUINT32Prop ( INDENT_1, "maxFramebufferWidth", limits.maxFramebufferWidth );
    PrintUINT32Prop ( INDENT_1, "maxFramebufferHeight", limits.maxFramebufferHeight );
    PrintUINT32Prop ( INDENT_1, "maxFramebufferLayers", limits.maxFramebufferLayers );

    PrintVkFlagsProp ( INDENT_1,
        "framebufferColorSampleCounts",
        limits.framebufferColorSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "framebufferDepthSampleCounts",
        limits.framebufferDepthSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "framebufferStencilSampleCounts",
        limits.framebufferStencilSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "framebufferNoAttachmentsSampleCounts",
        limits.framebufferNoAttachmentsSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintUINT32Prop ( INDENT_1, "maxColorAttachments", limits.maxColorAttachments );

    PrintVkFlagsProp ( INDENT_1,
        "sampledImageColorSampleCounts",
        limits.sampledImageColorSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "sampledImageIntegerSampleCounts",
        limits.sampledImageIntegerSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "sampledImageDepthSampleCounts",
        limits.sampledImageDepthSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "sampledImageStencilSampleCounts",
        limits.sampledImageStencilSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "storageImageSampleCounts",
        limits.storageImageSampleCounts,
        g_vkSampleCountFlagMapperItems,
        g_vkSampleCountFlagMapper
    );

    PrintUINT32Prop ( INDENT_1, "maxSampleMaskWords", limits.maxSampleMaskWords );
    PrintVkBool32Prop ( INDENT_1, "timestampComputeAndGraphics", limits.timestampComputeAndGraphics );
    PrintFloatProp ( INDENT_1, "timestampPeriod", limits.timestampPeriod );
    PrintUINT32Prop ( INDENT_1, "maxClipDistances", limits.maxClipDistances );
    PrintUINT32Prop ( INDENT_1, "maxCullDistances", limits.maxCullDistances );
    PrintUINT32Prop ( INDENT_1, "maxCombinedClipAndCullDistances", limits.maxCombinedClipAndCullDistances );
    PrintUINT32Prop ( INDENT_1, "discreteQueuePriorities", limits.discreteQueuePriorities );
    PrintFloatVec2Prop ( INDENT_1, "pointSizeRange", limits.pointSizeRange );
    PrintFloatVec2Prop ( INDENT_1, "lineWidthRange", limits.lineWidthRange );
    PrintFloatProp ( INDENT_1, "pointSizeGranularity", limits.pointSizeGranularity );
    PrintFloatProp ( INDENT_1, "lineWidthGranularity", limits.lineWidthGranularity );
    PrintVkBool32Prop ( INDENT_1, "strictLines", limits.strictLines );
    PrintVkBool32Prop ( INDENT_1, "standardSampleLocations", limits.standardSampleLocations );

    PrintSizeProp ( INDENT_1,
        "optimalBufferCopyOffsetAlignment",
        static_cast<size_t> ( limits.optimalBufferCopyOffsetAlignment )
    );

    PrintSizeProp ( INDENT_1,
        "optimalBufferCopyRowPitchAlignment",
        static_cast<size_t> ( limits.optimalBufferCopyRowPitchAlignment )
    );

    PrintSizeProp ( INDENT_1, "nonCoherentAtomSize", static_cast<size_t> ( limits.nonCoherentAtomSize ) );
}

void Renderer::PrintPhysicalDeviceMemoryProperties ( VkPhysicalDevice physicalDevice )
{
    vkGetPhysicalDeviceMemoryProperties ( physicalDevice, &_physicalDeviceMemoryProperties );

    LogInfo ( ">>> Memory properties:" );
    PrintUINT32Prop ( INDENT_1, "memoryTypeCount", _physicalDeviceMemoryProperties.memoryTypeCount );

    for ( uint32_t i = 0U; i < _physicalDeviceMemoryProperties.memoryTypeCount; ++i )
    {
        const VkMemoryType& type = _physicalDeviceMemoryProperties.memoryTypes[ i ];
        LogInfo ( "%smemoryType: #%u", INDENT_2, i );

        PrintVkFlagsProp ( INDENT_3,
            "memoryTypes",
            type.propertyFlags,
            g_vkMemoryPropertyFlagBitsMapperItems,
            g_vkMemoryPropertyFlagBitsMapper
        );

        PrintUINT32Prop ( INDENT_3, "heapIndex", type.heapIndex );
    }

    PrintUINT32Prop ( INDENT_1, "memoryHeapCount", _physicalDeviceMemoryProperties.memoryHeapCount );

    for ( uint32_t i = 0U; i < _physicalDeviceMemoryProperties.memoryHeapCount; ++i )
    {
        const VkMemoryHeap& heap = _physicalDeviceMemoryProperties.memoryHeaps[ i ];

        LogInfo ( "%smemoryHeap: #%u", INDENT_2, i );
        PrintSizeProp ( INDENT_3, "size", static_cast<size_t> ( heap.size ) );

        PrintVkFlagsProp ( INDENT_3,
            "memoryTypes",
            heap.flags,
            g_vkMemoryHeapFlagBitsMapperItems,
            g_vkMemoryHeapFlagBitsMapper
        );
    }
}

bool Renderer::PrintPhysicalDeviceInfo ( uint32_t deviceIndex, VkPhysicalDevice physicalDevice )
{
    LogInfo ( "Renderer::PrintPhysicalDeviceInfo - Vulkan physical device #%u", deviceIndex );

    VkPhysicalDeviceProperties props;
    vkGetPhysicalDeviceProperties ( physicalDevice, &props );

    PrintVkHandler ( INDENT_1, "Device handler", physicalDevice );

    PrintPhysicalDeviceCommonProps ( props );
    PrintPhysicalDeviceLimits ( props.limits );
    PrintPhysicalDeviceSparse ( props.sparseProperties );
    PrintPhysicalDeviceFeatureInfo ( physicalDevice );
    PrintPhysicalDeviceExtensionInfo ( physicalDevice );
    PrintPhysicalDeviceLayerInfo ( physicalDevice );
    PrintPhysicalDeviceMemoryProperties ( physicalDevice );

    uint32_t queueFamilyCount = 0U;
    vkGetPhysicalDeviceQueueFamilyProperties ( physicalDevice, &queueFamilyCount, nullptr );

    if ( !queueFamilyCount )
    {
        LogError ( "Renderer::PrintPhysicalDeviceInfo - There is no any Vulkan physical device queue families." );
        assert ( !"Renderer::PrintPhysicalDeviceInfo - There is no any Vulkan physical device queue families." );

        return false;
    }

    LogInfo ( ">>> Vulkan physical device queue families detected: %u.", queueFamilyCount );

    std::vector<VkQueueFamilyProperties> queueFamilyProps ( static_cast<size_t> ( queueFamilyCount ) );
    VkQueueFamilyProperties* queueFamilyPropList = queueFamilyProps.data ();
    vkGetPhysicalDeviceQueueFamilyProperties ( physicalDevice, &queueFamilyCount, queueFamilyPropList );

    auto& info = _physicalDeviceInfo[ physicalDevice ];
    auto& queueFamilies = info._queueFamilyInfo;
    queueFamilies.reserve ( static_cast<size_t> ( queueFamilyCount ) );

    for ( uint32_t i = 0U; i < queueFamilyCount; ++i )
    {
        const VkQueueFamilyProperties& familyProps = queueFamilyPropList[ i ];
        PrintPhysicalDeviceQueueFamilyInfo ( i, familyProps );
        queueFamilies.push_back ( std::make_pair ( familyProps.queueFlags, familyProps.queueCount ) );
    }

    return true;
}

void Renderer::PrintPhysicalDeviceQueueFamilyInfo ( uint32_t queueFamilyIndex,
    const VkQueueFamilyProperties &props
) const
{
    LogInfo ( "%sQueue family: #%u", INDENT_1, queueFamilyIndex );

    PrintVkFlagsProp ( INDENT_2, "queueFlags", props.queueFlags, g_vkQueueFlagMapperItems, g_vkQueueFlagMapper );
    PrintUINT32Prop ( INDENT_2, "queueCount", props.queueCount );
    PrintUINT32Prop ( INDENT_2, "timestampValidBits", props.timestampValidBits );
    PrintVkExtent3DProp ( INDENT_2, "minImageTransferGranularity", props.minImageTransferGranularity );
}

void Renderer::PrintPhysicalDeviceSparse ( const VkPhysicalDeviceSparseProperties &sparse ) const
{
    LogInfo ( ">>> Sparse:" );

    PrintVkBool32Prop ( INDENT_1, "residencyStandard2DBlockShape", sparse.residencyStandard2DBlockShape );

    PrintVkBool32Prop ( INDENT_1,
        "residencyStandard2DMultisampleBlockShape",
        sparse.residencyStandard2DMultisampleBlockShape
    );

    PrintVkBool32Prop ( INDENT_1, "residencyStandard3DBlockShape", sparse.residencyStandard3DBlockShape );
    PrintVkBool32Prop ( INDENT_1, "residencyAlignedMipSize", sparse.residencyAlignedMipSize );
    PrintVkBool32Prop ( INDENT_1, "residencyNonResidentStrict", sparse.residencyNonResidentStrict );
}

void Renderer::PrintVkBool32Prop ( const char* indent, const char* name, VkBool32 value ) const
{
    LogInfo ( "%s%s: %s", indent, name, value ? "VK_TRUE" : "VK_FALSE" );
}

void Renderer::PrintVkExtent2DProp ( const char* indent, const char* name, const VkExtent2D &value ) const
{
    LogInfo ( "%s%s:", indent, name );
    LogInfo ( "%s%swidth: %u", indent, INDENT_1, value.width );
    LogInfo ( "%s%sheight: %u", indent, INDENT_1, value.height );
}

void Renderer::PrintVkExtent3DProp ( const char* indent, const char* name, const VkExtent3D &value ) const
{
    LogInfo ( "%s%s:", indent, name );
    LogInfo ( "%s%swidth: %u", indent, INDENT_1, value.width );
    LogInfo ( "%s%sheight: %u", indent, INDENT_1, value.height );
    LogInfo ( "%s%sdepth: %u", indent, INDENT_1, value.depth );
}

void Renderer::PrintVkExtensionProp ( uint32_t extensionIndex, const char* category, const VkExtensionProperties &extension ) const
{
    LogInfo ( "%s%s extension: #%u", INDENT_1, category, extensionIndex );

    PrintUTF8Prop ( INDENT_2, "extensionName", extension.extensionName );
    PrintUINT32Prop ( INDENT_2, "specVersion", extension.specVersion );
}

void Renderer::PrintVkFlagsProp ( const char* indent,
    const char* name,
    VkFlags flags,
    size_t flagSetCount,
    const std::pair<uint32_t, const char*> flagSet[]
) const
{
    if ( !flags )
    {
        LogInfo ( "%s%s: not set", indent, name );
        return;
    }

    std::string result;
    const auto bitmask = static_cast<const uint32_t> ( flags );

    for ( size_t i = 0U; i < flagSetCount; ++i )
    {
        const auto& item = flagSet[ i ];

        if ( !( item.first & bitmask ) ) continue;

        result += " ";
        result += item.second;
    }

    LogInfo ( "%s%s:%s", indent, name, result.c_str () );
}

void Renderer::PrintVkHandler ( const char* indent, const char* name, void* handler ) const
{
    LogInfo ( "%s%s: %p", indent, name, handler );
}

void Renderer::PrintVkLayerProperties ( uint32_t layerIndex, const VkLayerProperties &layer ) const
{
    LogInfo ( "%sLayer: #%u", INDENT_1, layerIndex );

    PrintUTF8Prop ( INDENT_2, "layerName", layer.layerName );
    PrintVkVersion ( INDENT_2, "specVersion", layer.specVersion );
    PrintUINT32Prop ( INDENT_2, "implementationVersion", layer.implementationVersion );
    PrintUTF8Prop ( INDENT_2, "description", layer.description );
}

void Renderer::PrintVkPresentModeProp ( uint32_t modeIndex, VkPresentModeKHR mode ) const
{
    LogInfo ( "%sMode: #%u", INDENT_1, modeIndex );
    PrintUTF8Prop ( INDENT_2, "type", ResolveVkPresentModeKHR ( mode ) );
}

void Renderer::PrintVkSurfaceCapabilities ( const VkSurfaceCapabilitiesKHR &caps )
{
    LogInfo ( ">>> Surface:" );

    PrintUINT32Prop ( INDENT_1, "minImageCount", caps.minImageCount );
    PrintUINT32Prop ( INDENT_1, "maxImageCount", caps.maxImageCount );
    PrintVkExtent2DProp ( INDENT_1, "currentExtent", caps.currentExtent );
    PrintVkExtent2DProp ( INDENT_1, "minImageExtent", caps.minImageExtent );
    PrintVkExtent2DProp ( INDENT_1, "maxImageExtent", caps.maxImageExtent );
    PrintUINT32Prop ( INDENT_1, "maxImageArrayLayers", caps.maxImageArrayLayers );

    PrintVkFlagsProp ( INDENT_1,
        "supportedTransforms",
        caps.supportedTransforms,
        g_vkSurfaceTransformFlagBitsKHRMapperItems,
        g_vkSurfaceTransformFlagBitsKHRMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "currentTransform",
        caps.currentTransform,
        g_vkSurfaceTransformFlagBitsKHRMapperItems,
        g_vkSurfaceTransformFlagBitsKHRMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "supportedCompositeAlpha",
        caps.supportedCompositeAlpha,
        g_vkCompositeAlphaFlagBitsKHRMapperItems,
        g_vkCompositeAlphaFlagBitsKHRMapper
    );

    PrintVkFlagsProp ( INDENT_1,
        "supportedUsageFlags",
        caps.supportedUsageFlags,
        g_vkImageUsageFlagBitsMapperItems,
        g_vkImageUsageFlagBitsMapper
    );
}

void Renderer::PrintVkSurfaceFormatKHRProp ( uint32_t formatIndex, const VkSurfaceFormatKHR &format ) const
{
    LogInfo ( "%sSurface format: #%u", INDENT_1, formatIndex );

    PrintUTF8Prop ( INDENT_2, "format", ResolveVkFormat ( format.format ) );
    PrintUTF8Prop ( INDENT_2, "colorSpace ", ResolveVkColorSpaceKHR ( format.colorSpace ) );
}

void Renderer::PrintVkVersion ( const char* indent, const char* name, uint32_t version ) const
{
    LogInfo ( "%s%s: %u.%u.%u",
        indent,
        name,
        VK_VERSION_MAJOR ( version ),
        VK_VERSION_MINOR ( version ),
        VK_VERSION_PATCH ( version )
    );
}

void Renderer::PrintSizeProp ( const char* indent, const char* name, size_t value ) const
{
    LogInfo ( "%s%s: %zu", indent, name, value );
}

void Renderer::PrintUINT32Prop ( const char* indent, const char* name, uint32_t value ) const
{
    LogInfo ( "%s%s: %u", indent, name, value );
}

void Renderer::PrintUINT32Vec2Prop ( const char* indent, const char* name, const uint32_t value[] ) const
{
    LogInfo ( "%s%s: %u, %u", indent, name, value[ 0U ], value[ 1U ] );
}

void Renderer::PrintUINT32Vec3Prop ( const char* indent, const char* name, const uint32_t value[] ) const
{
    LogInfo ( "%s%s: %u, %u, %u", indent, name, value[ 0U ], value[ 1U ], value[ 2U ] );
}

void Renderer::PrintUTF8Prop ( const char* indent, const char* name, const char* value ) const
{
    LogInfo ( "%s%s: %s", indent, name, value );
}

const char* Renderer::ResolvePhysicalDeviceType ( VkPhysicalDeviceType type ) const
{
    const auto findResult = _vulkanPhysicalDeviceTypeMap.find ( type );
    return findResult == _vulkanPhysicalDeviceTypeMap.cend () ? UNKNOWN_RESULT : findResult->second;
}

const char* Renderer::ResolveVkDebugReportObjectType ( VkDebugReportObjectTypeEXT type ) const
{
    const auto findResult = _vulkanObjectTypeMap.find ( type );
    return findResult == _vulkanObjectTypeMap.cend () ? UNKNOWN_RESULT : findResult->second;
}

const char* Renderer::ResolveVkColorSpaceKHR ( VkColorSpaceKHR colorSpace ) const
{
    const auto findResult = _vulkanColorSpaceMap.find ( colorSpace );
    return findResult == _vulkanColorSpaceMap.cend () ? UNKNOWN_RESULT : findResult->second;
}

const char* Renderer::ResolveVkFormat ( VkFormat format ) const
{
    const auto findResult = _vulkanFormatMap.find ( format );
    return findResult == _vulkanFormatMap.cend () ? UNKNOWN_RESULT : findResult->second;
}

const char* Renderer::ResolveVkPresentModeKHR ( VkPresentModeKHR mode ) const
{
    const auto findResult = _vulkanPresentModeMap.find ( mode );
    return findResult == _vulkanPresentModeMap.cend () ? UNKNOWN_RESULT : findResult->second;
}

const char* Renderer::ResolveVkResult ( VkResult result ) const
{
    const auto findResult = _vulkanResultMap.find ( result );

    if ( findResult != _vulkanResultMap.cend () )
        return findResult->second;

    constexpr static const char* unknownResult = "UNKNOWN";
    return unknownResult;
}

bool Renderer::SelectTargetHardware ( VkPhysicalDevice &targetPhysicalDevice, uint32_t &targetQueueFamilyIndex ) const
{
    // Find physical device with graphic and compute queues.

    for ( auto const& device : _physicalDeviceInfo )
    {
        const auto& queueFamilyInfo = device.second._queueFamilyInfo;
        const size_t count = queueFamilyInfo.size ();

        for ( size_t i = 0U; i < count; ++i )
        {
            const VkFlags queueFamilyFlags = queueFamilyInfo[ i ].first;

            if ( !( queueFamilyFlags & VK_QUEUE_COMPUTE_BIT ) || !( queueFamilyFlags & VK_QUEUE_GRAPHICS_BIT ) )
                continue;

            targetPhysicalDevice = device.first;
            targetQueueFamilyIndex = static_cast<uint32_t> ( i );

            return true;
        }
    }

    LogError ( "Renderer::SelectTargetHardware - Can't find target hardware!" );
    assert ( !"Renderer::SelectTargetHardware - Can't find target hardware!" );
    return false;
}

bool Renderer::SelectTargetPresentMode ( VkPresentModeKHR &targetPresentMode, bool vSync ) const
{
    // Try to find VK_PRESENT_MODE_MAILBOX_KHR present mode.

    const VkPresentModeKHR desirableMode = vSync ? VK_PRESENT_MODE_FIFO_KHR : VK_PRESENT_MODE_MAILBOX_KHR;

    uint32_t modeCount = 0U;

    const bool result = CheckVkResult (
        vkGetPhysicalDeviceSurfacePresentModesKHR ( _physicalDevice,
            _surface,
            &modeCount,
            nullptr
        ),

        "Renderer::SelectTargetPresentMode",
        "Can't get Vulkan present modes"
    );

    if ( !result )
        return false;

    LogInfo ( "Renderer::SelectTargetPresentMode - Present modes detected: %u.", modeCount );

    std::vector<VkPresentModeKHR> modes ( static_cast<size_t> ( modeCount ) );
    VkPresentModeKHR* modeList = modes.data ();
    vkGetPhysicalDeviceSurfacePresentModesKHR ( _physicalDevice, _surface, &modeCount, modeList );

    targetPresentMode = VK_PRESENT_MODE_FIFO_KHR;

    for ( uint32_t i = 0U; i < modeCount; ++i )
    {
        const VkPresentModeKHR mode = modeList[ i ];
        PrintVkPresentModeProp ( i, mode );

        if ( mode != desirableMode )
            continue;

        targetPresentMode = mode;
    }

    LogInfo ( "Renderer::SelectTargetPresentMode - Presented mode selected: %s.",
        ResolveVkPresentModeKHR ( targetPresentMode )
    );

    return true;
}

bool Renderer::SelectTargetSurfaceFormat ( VkFormat &targetColorFormat,
    VkColorSpaceKHR &targetColorSpace,
    VkFormat &targetDepthStencilFormat
) const
{
    // Find sRGBA8 format.

    if ( _surfaceFormats[ 0U ].format == VK_FORMAT_UNDEFINED )
    {
        targetColorFormat = VK_FORMAT_R8G8B8A8_SRGB;
        targetColorSpace = _surfaceFormats[ 0U ].colorSpace;
    }
    else
    {
        bool isFound = false;

        for ( auto const& item : _surfaceFormats )
        {
            if ( item.format != VK_FORMAT_R8G8B8A8_SRGB )
                continue;

            targetColorFormat = VK_FORMAT_R8G8B8A8_SRGB;
            targetColorSpace = _surfaceFormats[ 0U ].colorSpace;
            isFound = true;

            break;
        }

        if ( !isFound )
        {
            return false;
        }
    }

    constexpr const VkFormat depthStencilOptions[]
    {
        VK_FORMAT_D32_SFLOAT_S8_UINT,
        VK_FORMAT_D24_UNORM_S8_UINT,
        VK_FORMAT_D16_UNORM_S8_UINT
    };

    for ( auto probe : depthStencilOptions )
    {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties ( _physicalDevice, probe, &props );

        if ( !( props.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT ) ) continue;

        targetDepthStencilFormat = probe;

        constexpr const char* format = R"__(Renderer::SelectTargetSurfaceFormat - Surface format selected:
%sColor format: %s
%sColor space: %s
%sDepth|stencil format: %s
)__";

        LogInfo ( format,
            INDENT_1,
            ResolveVkFormat ( targetColorFormat ),
            INDENT_1,
            ResolveVkColorSpaceKHR ( targetColorSpace ),
            INDENT_1,
            ResolveVkFormat ( targetDepthStencilFormat )
        );

        return true;
    }

    LogError ( "Renderer::SelectTargetSurfaceFormat - Can't select depth|stencil format." );
    assert ( !"Renderer::SelectTargetSurfaceFormat - Can't select depth|stencil format." );

    return false;
}

VkBool32 VKAPI_PTR Renderer::OnVulkanDebugReport ( VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage,
    void* pUserData
)
{
    Renderer& renderer = *static_cast<Renderer*> ( pUserData );
    const auto findResult = renderer._loggerMapper.find ( flags );

    const char* category = nullptr;
    LogType logger = nullptr;

    if ( findResult != renderer._loggerMapper.cend () )
    {
        category = findResult->second.second;
        logger = findResult->second.first;
    }
    else
    {
        constexpr static const char* unknownCategory = "UNKNOWN";
        category = unknownCategory;
        logger = &LogError;
    }

    constexpr const char* format =
R"__(Renderer::OnVulkanDebugReport:
category: %s
object type: %s
object: 0x%)__" PRIx64
R"__(
location: %zu
message code: %i
layer prefix: %s
message: %s
)__";

    logger ( format,
        category,
        renderer.ResolveVkDebugReportObjectType ( objectType ),
        object,
        location,
        messageCode,
        pLayerPrefix,
        pMessage
    );

    return VK_FALSE;
}

} // namespace android_vulkan
