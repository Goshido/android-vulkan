#include "lightup-common-descriptor-set.ps"

#define PREFILTER_MAX_MIP_LEVEL     8.0F
#define MINIMUM_F0                  4.0e-2H
#define VOID_SPACE_DEPTH            1.0F

[[vk::binding ( 0, 1 )]]
TextureCube<float4>         g_prefilter:            register ( t0 );

[[vk::binding ( 1, 1 )]]
SamplerState                g_prefilterSampler:     register ( s0 );

[[vk::binding ( 2, 1 )]]
Texture2D<float4>           g_brdf:                 register ( t1 );

[[vk::binding ( 3, 1 )]]
SamplerState                g_brdfSampler:          register ( s1 );

[[vk::binding ( 4, 1 )]]
cbuffer Transform:                                  register ( b1 )
{
    matrix                  _viewToWorld;
};

struct InputData
{
    linear float4           _pixel:         SV_Position;
};

struct OutputData
{
    [[vk::location (0)]]
    float4                  _color:         SV_Target0;
};

//----------------------------------------------------------------------------------------------------------------------

half3 GetAlbedo ()
{
    return (half3)g_albedo.SubpassLoad ().xyz;
}

float GetDepth ()
{
    return g_depth.SubpassLoad ();
}

half3 GetFresnel ( in half nH, in half metallic, in half3 albedo )
{
    const half3 f0 = lerp ( (half3)MINIMUM_F0, albedo, (half3)metallic );
    return mad ( 1.0H - f0, pow ( max ( 0.0H, 1.0H - nH ), 5.0H ), f0 );
}

void GetParams ( out float roughness, out half metallic )
{
    const float4 paramSample = g_params.SubpassLoad ();
    roughness = paramSample.x;
    metallic = (half)paramSample.z;
}

half3 RestoreDirectionView ( in float2 locationImage, in float depth )
{
    const float2 alpha = mad ( locationImage, _invResolutionFactor, (float2)( -1.0F ) );
    const float4 v = mul ( _cvvToView, float4 ( alpha, depth, 1.0F ) );
    return normalize ( (half3)v.xyz );
}

half3 RestoreNormalView ()
{
    const half3 alpha = (half3)g_normal.SubpassLoad ().xyz;
    return mad ( alpha, (half3)2.0H, (half3)( -1.0H ) );
}

float Roughness2Mip ( in float roughness )
{
    // It's emperical ease function. Please plot the graph to see what happens.
    const float mip = 8.42F + ( 0.01F - 8.42F ) / ( 1.0F + pow ( roughness / 0.2584F, 2.164F ) );
    return clamp ( mip, 0.0F, PREFILTER_MAX_MIP_LEVEL );
}

OutputData PS ( in InputData inputData )
{
    const float depth = GetDepth ();
    OutputData result;

    if ( depth == VOID_SPACE_DEPTH )
    {
        result._color = (float4)0.0F;
        discard;
        return result;
    }

    float roughness;
    half metallic;
    GetParams ( roughness, metallic );

    const half3 directionView = -RestoreDirectionView ( inputData._pixel.xy, depth );
    const half3 normalView = RestoreNormalView ();
    const half dN = max ( 0.0H, dot ( directionView, normalView ) );
    const half3 freshnel = GetFresnel ( dN, metallic, GetAlbedo () );

    const float3 refl = -mul ( (float3x3)_viewToWorld, (float3)( reflect ( directionView, normalView ) ) );
    const float mip = Roughness2Mip ( roughness );

    const half3 prefilterColor = (half3)g_prefilter.SampleLevel ( g_prefilterSampler, refl, mip ).xyz;
    const half2 brdf = (half2)g_brdf.Sample ( g_brdfSampler, float2 ( (float)dN, 1.0F - roughness ) ).xy;

    result._color = float4 ( (float3)( prefilterColor * mad ( freshnel, (half3)brdf.x, (half3)brdf.y ) ), 0.0F );
    return result;
}
